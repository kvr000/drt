#!/usr/bin/perl

###
## drt library
##
## drt multiplatform development toolkit
##
## ----------------------------------------------------------------------------------
##
## Copyright (C) 2004-2008 Zbyněk Vyškovský
##
## ----------------------------------------------------------------------------------
##
## LICENSE:
##
## This file is part of drt
##
## drt is free software; you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation; either version 3 of the License, or (at your option)
## any later version.
##
## drt is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
## more details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with drt; if not, write to the Free Software Foundation, Inc., 51
## Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
##
## @copyright	2004-2008 Zbyněk Vyškovský
## @link	mailto:kvr@matfyz.cz
## @link	http://kvr.matfyz.cz/drt/
## @license	http://www.gnu.org/licenses/lgpl.txt GNU Lesser General Public License v3
###

use strict;
use warnings;

use FileHandle;
use Data::Dumper;
use Getopt::Std;

use File::Basename;
use File::Find;
use lib dirname($0)."/perl";
use dr::FileTransaction;
use dr::FileParser;
use dr::ModelStore;
use dr::TagWriter;
use dr::Util qw(tabalign escapeString makeLineEnd indentString textToString escapeStringContent convertBool);
use dr::prog::java::JavaGenerator;
use dr::prog::java::JavaOutFileContext;
use dr::prog::java::JavaOutputGenerator;
use dr::prog::gen::CopyGenerator;


our %opts;
our $file_trans;


sub convertToJavaClass
{
	my $classname			= shift;

	$classname =~ s/::/./g;

	return $classname;
}

sub escapeJavaTypeValue
{
	my $java_type			= shift;
	my $value			= shift;

	return "${value}L" if ($java_type eq "Long");
	return escapeStringContent($value) if ($java_type eq "String");
	return $value ? "true" : "false" if ($java_type eq "Boolean");
	return $value;
}

sub translateJavaType # translatedString <- importCtx baseModel javaType-string
{
	my $importCtx			= shift;
	my $baseModel			= shift;
	my $javaType			= shift;

	if ($javaType->{type} =~ m/^(\w+)\s*<\s*(.*)\s*>$/) {
		my $structBase = $1;
		my $elementType = $2;
		$importCtx->printOnce("import ".dr::prog::java::JavaGenerator::mapJavaDatastruct($structBase).";\n");
		my $elementName;
		if ($elementType eq ".") {
			$elementName = $baseModel->getFullDotName();
		}
		else {
			$elementName = dr::prog::java::JavaGenerator::mapJavaPlain($baseModel, $elementType);
		}
		return "$structBase<$elementName>";
	}
	else {
		dr::prog::java::JavaGenerator::mapJavaType($javaType);
	}
}

sub getDataSource($)
{
	my $classdef			= shift;

	return $classdef->checkDrTagHierarchicalValue("datasource") || dr::Util::doDie("failed to find datasource for class $classdef->{name}");
}

sub convertPkType($)
{
	my $model			= shift;

	my @primary = $model->getPrimary();
	if (@primary > 1) {
		return $model->{name}.".Pk";
	}
	else {
		return dr::prog::java::JavaGenerator::mapJavaAttrType($primary[0]);
	}
}

sub printFieldDef($$$$$$$)
{
	my $context			= shift;
	my $javaOut			= shift;
	my $printCtx			= shift;
	my $model			= shift;
	my $field			= shift;
	my $tagger			= shift;
	my $javaType			= shift;

	my $dfl = (defined $field->{default}) ?
		" = ".escapeJavaTypeValue($javaType, $field->{default}) :
		(defined $field->checkDrTagValue("do_mandatory")) ? " = ".escapeJavaTypeValue($javaType, $field->checkDrTagValue("do_mandatory")) :
		"";

	if (defined (my $logical = $tagger->checkTagValue("logical"))) {
		$javaOut->printSysimport("import dr.logical.LogicalUse;\n");
		$printCtx->print("\@LogicalUse(logical = ".convertToJavaClass($logical).".class)\n");
	}
	if (defined (my $display = $tagger->checkTagValue("display"))) {
		$javaOut->printSysimport("import dr.logical.DisplayUse;\n");
		my $displayAdd = "";
		if ($field->{stype} eq "assoc") {
			$displayAdd .= ", refClass = \"".escapeString($field->getAssocTarget())->getFullDotName()."\"";
		}
		$printCtx->print("\@DisplayUse(display = \"".escapeString($display)."\"$displayAdd)\n");
	}
	$javaOut->printSysimport("import dr.meta.FieldRoles;\n");
	$printCtx->print("\@FieldRoles(".dr::prog::java::JavaGenerator::formatFieldRoles($model, $field).")\n");
	$javaOut->printSysimport("import dr.meta.Mandatory;\n");
	$printCtx->print("\@Mandatory(mandatory = ".dr::prog::java::JavaGenerator::formatBoolean($field->{mandatory}).(defined $field->checkDrTagValue("do_mandatory") ? ", doMandatory = \"".escapeString($field->checkDrTagValue("do_mandatory"))."\"" : "").")\n");
	$printCtx->print(tabalign("protected $javaType", 32)."$field->{name}$dfl;\n");
}

sub generateEntityBeanPart($$$)
{
	my $context			= shift;
	my $javaOut			= shift;
	my $model			= shift;

	my $codeCtx			= $javaOut->{codeCtx};

	my $classname = $model->{name};
	my $jclassname = $classname; $jclassname =~ s/::/./g;
	my $filename = $jclassname; $filename =~ s/\./\//g;
	my $pkgname = $jclassname; $pkgname =~ s/\.\w+$//;
	my $classonly = $jclassname; $classonly =~ s/^.*\.//g;

	my $dao = $model->checkSubModel("${classname}::Dao");

	$javaOut->printSysimport("import javax.persistence.Entity;\n");
	$javaOut->printSysimport("import javax.persistence.Table;\n");

	my $clsCtx = $codeCtx->subContext();
	if (defined (my $roleProcessor = ($dao && $dao->checkDrTagValue("roleProcessor")) // $model->checkDrTagValue("roleProcessor"))) {
		$javaOut->printSysimport("import dr.dao.RoleProcessorUse;\n");
		$codeCtx->print("\@RoleProcessorUse(roleProcessor = ".convertToJavaClass($roleProcessor).".class)\n");
	}
	$javaOut->printSysimport("import dr.meta.ViewsList;\n");
	$codeCtx->print("\@ViewsList(views = {\n");
	if (!@{$model->{view_list}}) {
		$javaOut->printSysimport("import dr.meta.ViewInfo;\n");
		$codeCtx->print("\t\@ViewInfo(name = \"Default\"),\n");
	}
	foreach my $view (@{$model->{view_list}}) {
		$javaOut->printSysimport("import dr.meta.ViewInfo;\n");
		$codeCtx->print("\t\@ViewInfo(name = \"$view->{name}\"");
		eval {
			foreach (qw(supplier renderer clientClass)) { # (qw(nocompos suggest supplier renderer addcompos iniclass gui_filter view_fields))
				if (defined (my $v = $view->checkDrTagValue($_))) {
					$codeCtx->print(", $_ = \"$v\"");
				}
			}
			foreach (qw(fields actions)) {
				if (defined (my $v = $view->checkDrTagValue($_))) {
					$codeCtx->print(", $_ = { ".join(", ", map({ textToString($_) } split(/,\s*/, $v)))." }");
				}
			}
			1;
		}
			or dr::Util::doDie("failed to process view $model->{full}.$view->{name}:\n$@");
		$codeCtx->print("),\n");
	}
	$codeCtx->print("})\n");

	if (defined (my $suggestFields = $model->checkDrTagValue("suggestFields"))) {
		$javaOut->printSysimport("import dr.meta.SuggestDef;\n");
		$codeCtx->print("\@SuggestDef(fields = { ".join(", ", map({ "\"$_\"" } split(/,\s*/, $suggestFields)))." })\n");
	}
	if (defined (my $orderFields = $model->checkDrTagValue("order"))) {
		$javaOut->printSysimport("import dr.meta.ListOrder;\n");
		$codeCtx->print("\@ListOrder(order = { ".join(", ", map({ "\"$_\"" } split(/,\s*/, $orderFields)))." })\n");
	}
	$javaOut->printSysimport("import dr.meta.FieldRoles;\n");
	$codeCtx->print("\@FieldRoles(".dr::prog::java::JavaGenerator::formatClassRoles($model).")\n");
	$codeCtx->print("\@Entity\n\@Table(name=\"$classonly\")\npublic class $classonly implements java.io.Serializable\n{\n");
	my $inner = $codeCtx->indentContext(1);
	$inner->print(tabalign("private static final long", 32)."serialVersionUID = 1L;\n\n");
	my $nested_out = $javaOut->dupWithFileContext($inner->subContext());
	my $pkCtx = $inner->subContext();
	my $pk_fieldCtx = $pkCtx->subAfterContext()->indentContext(1);
	my $pk_methodCtx = $pkCtx->subAfterContext()->indentContext(1);
	my $pk_endCtx = $inner->subContext();
	$inner->print("\n");
	my $fieldCtx = $inner->subContext();
	$inner->print("\n");
	my $methodCtx = $inner->subContext();

	my @primary = $model->getPrimary();

	my $fieldOrder = "";
	my $pkOrder = "";
	my $relations = "";

	foreach my $nested_name (@{$model->getNestedNames()}) {
		#STDERR->print("processing nested $nested_name\n");
		my $nested = $model->checkSubModel("$model->{full}::$nested_name")
			or dr::Util::doDie("failed to load nested class $model->{full}::$nested_name");
		if ($nested->{stype} eq "enum") {
			dr::prog::java::JavaOutputGenerator->new($nested_out)->generateNested($nested);
			$nested_out->printCode("\n");
		}
	}

	my $use_pk = @primary > 1;

	my $pkDirect = !$use_pk;
	my $pkClazz = undef;
	my $pkField = "";
	my $addPkFields = "";
	my $composPkClazz = undef;
	my $pkComposField = undef;

	foreach my $field (@{$model->getAttrs()}) {
		my $primary_level = $field->getRole()->{primary} ? @primary > 1 : -1;
		if ($field->{stype} eq "field") {
			my ( $type, $tagger ) = $field->getFinalTypeWithTagger();
			my $java_type = dr::prog::java::JavaGenerator::mapJavaAttrType($field);
			my $method = ucfirst($field->{name});
			$javaOut->printSysimport("import javax.persistence.Column;\n");
			my $tmap = "";
			$tmap .= "\@Column(name=\"".$field->{name}."\")\n";
			if ($field->checkDrTagValue("serial")) {
				$javaOut->printSysimport("import javax.persistence.GenerationType;\n");
				$javaOut->printSysimport("import javax.persistence.GeneratedValue;\n");
				$tmap .= "\@GeneratedValue(strategy=GenerationType.AUTO)\n";
			}
			my $athis = $primary_level > 0 ? "this.pk" : "this";
			if ($primary_level > 0) {
				$addPkFields .= "\"$field->{name}\", ";
				$pk_fieldCtx->print($tmap);
				printFieldDef($context, $javaOut, $pk_fieldCtx, $model, $field, $tagger, $java_type);
				$pkOrder .= ", \"".escapeString($field->{name})."\"";
			}
			elsif ($primary_level == 0) {
				$fieldCtx->print($tmap);
				$javaOut->printSysimport("import javax.persistence.Id;\n");
				$fieldCtx->print("\@Id\n");
				printFieldDef($context, $javaOut, $fieldCtx, $model, $field, $tagger, $java_type);
				$pkClazz = "$java_type";
				$pkField = $field->{name};
				$fieldOrder .= ", \"".escapeString($field->{name})."\"";
			}
			else {
				$fieldCtx->print($tmap);
				printFieldDef($context, $javaOut, $fieldCtx, $model, $field, $tagger, $java_type);
				$fieldOrder .= ", \"".escapeString($field->{name})."\"";
			}
			if ($primary_level == 0) {
				$methodCtx->print(tabalign("public $java_type", 32)."getPk()\n{\n\treturn $field->{name};\n}\n\n");
				$methodCtx->print(tabalign("public void", 32)."setPk($java_type $field->{name}_)\n{\n\tthis.$field->{name} = $field->{name}_;\n}\n\n");
			}
			$methodCtx->print(tabalign("public void", 32)."set$method($java_type $field->{name}_)\n{\n\t$athis.$field->{name} = $field->{name}_;\n}\n\n");
			$methodCtx->print(tabalign("public $java_type", 32)."get$method()\n{\n\treturn $athis.$field->{name};\n}\n\n");
			if ($primary_level > 0) {
				$pk_methodCtx->print(tabalign("public void", 32)."set$method($java_type $field->{name}_)\n{\n\tthis.$field->{name} = $field->{name}_;\n}\n\n");
				$pk_methodCtx->print(tabalign("public $java_type", 32)."get$method()\n{\n\treturn this.$field->{name};\n}\n\n");
			}
		}
		elsif ($field->{stype} eq "child") {
			my $assoc_class = $field->getAssocTarget();
			if ($field->checkDrTagValue("tied")) {
				$javaOut->printAppimport("import ".convertToJavaClass($assoc_class->{full}).";\n");
				$javaOut->printSysimport("import javax.persistence.OneToMany;\n");
				$javaOut->printSysimport("import javax.persistence.JoinColumns;\n");
				$javaOut->printSysimport("import javax.persistence.JoinColumn;\n");
				$javaOut->printSysimport("import javax.persistence.FetchType;\n");
				$javaOut->printSysimport("import javax.persistence.CascadeType;\n");
				$javaOut->printSysimport("import java.util.Set;\n");
				$javaOut->printSysimport("import java.util.HashSet;\n");
				my $tmap = "";
				$tmap .= "\@OneToMany(fetch=FetchType.EAGER, cascade=CascadeType.ALL)\n";
				$tmap .= "\@JoinColumns({ ".
				join(", ", map({ "\@JoinColumn(name = \"$_->{name}\", referencedColumnName = \"$_->{name}\")" } $assoc_class->getCompos()->expandAssocAttrs())).
				" })\n";
				$fieldCtx->print($tmap.tabalign("private Set<$assoc_class->{name}>", 32)."$field->{name} = new HashSet<$assoc_class->{name}>();\n\n");
				$methodCtx->print(tabalign("public Set<$assoc_class->{name}>", 32)."get".ucfirst($field->{name})."()\n{\n\treturn $field->{name};\n}\n\n");
				$methodCtx->print(tabalign("public void", 32)."set".ucfirst($field->{name})."(Set<$assoc_class->{name}> $field->{name}_)\n{\n\tthis.$field->{name} = $field->{name}_;\n}\n\n");
				$fieldOrder .= ", \"".escapeString($field->{name})."\"";
			}
			$relations .= "\t\@RelationDef(name = \"$field->{name}\", targetClass = ".textToString($assoc_class->getFullDotName())."),\n";
		}
		elsif ($field->{stype} eq "assoc") {
			my ( $type, $tagger ) = $field->getFinalTypeWithTagger();
			my $java_type = dr::prog::java::JavaGenerator::mapJavaAttrType($field);
			my $method = ucfirst($field->{name});
			$javaOut->printSysimport("import javax.persistence.Column;\n");
			my $tmap = "";
			$tmap .= "\@Column(name=\"".$field->{name}."\")\n";
			if ($field->checkDrTagValue("serial")) {
				$javaOut->printSysimport("import javax.persistence.GenerationType;\n");
				$javaOut->printSysimport("import javax.persistence.GeneratedValue;\n");
				$tmap .= "\@GeneratedValue(strategy=GenerationType.AUTO)\n";
			}
			my $dfl = (defined $field->{default}) ?
				" = ".escapeJavaTypeValue($java_type, $field->{default}) :
				(defined $field->checkDrTagValue("do_mandatory")) ? " = ".escapeJavaTypeValue($java_type, $field->checkDrTagValue("do_mandatory")) :
				"";
			my $athis = $primary_level > 0 ? "this.pk" : "this";
			if ($primary_level > 0) {
				$addPkFields .= "\"$field->{name}\", ";
				printFieldDef($context, $javaOut, $pk_fieldCtx, $model, $field, $tagger, $java_type);
				$pkOrder .= ", \"".escapeString($field->{name})."\"";
			}
			elsif ($primary_level == 0) {
				$fieldCtx->print($tmap);
				$javaOut->printSysimport("import javax.persistence.Id;\n");
				$fieldCtx->print("\@Id\n");
				printFieldDef($context, $javaOut, $fieldCtx, $model, $field, $tagger, $java_type);
				$fieldOrder .= ", \"".escapeString($field->{name})."\"";
			}
			else {
				$fieldCtx->print($tmap);
				printFieldDef($context, $javaOut, $fieldCtx, $model, $field, $tagger, $java_type);
				$fieldOrder .= ", \"".escapeString($field->{name})."\"";
			}
			if ($primary_level == 0) {
				$methodCtx->print(tabalign("public $java_type", 32)."getPk()\n{\treturn $field->{name};\n}\n\n");
				$methodCtx->print(tabalign("public void", 32)."setPk($java_type $field->{name}_)\n{\tthis.$field->{name} = $field->{name}_;\n}\n\n");
			}
			$methodCtx->print(tabalign("public void", 32)."set$method($java_type $field->{name}_)\n{\n\t$athis.$field->{name} = $field->{name}_;\n}\n\n");
			$methodCtx->print(tabalign("public $java_type", 32)."get$method()\n{\n\treturn $athis.$field->{name};\n}\n\n");
			if ($primary_level > 0) {
				$pk_methodCtx->print(tabalign("public void", 32)."set$method($java_type $field->{name}_)\n{\n\tthis.$field->{name} = $field->{name}_;\n}\n\n");
				$pk_methodCtx->print(tabalign("public $java_type", 32)."get$method()\n{\n\treturn this.$field->{name};\n}\n\n");
			}
		}
		elsif ($field->{stype} eq "compos") {
			my $compos = $field->getAssocTarget();
			my $compos_class = convertToJavaClass($compos->{name});
			my $pktype = convertPkType($compos);
			#$javaOut->printSysimport("import dr.meta.ComposDef;\n");
			#$clsCtx->print("\@ComposDef(clazz = ".$compos->getFullDotName().".class, pkclazz = ".convertPkType($compos).".class, path = \"pk.$field->{name}\", composKeySetter = \"set".ucfirst($field->{name})."\")\n");
			$pkComposField = $field->{name};
			$composPkClazz = convertPkType($compos);
			$pk_fieldCtx->print("\@Column(name=\"$field->{name}\")\n");
			$pk_fieldCtx->print("\@FieldRoles(".dr::prog::java::JavaGenerator::formatFieldRoles($model, $field).")\n");
			$pk_fieldCtx->print(tabalign("public $pktype", 32)."$field->{name};\n\n");
			$methodCtx->print(tabalign("public void", 32)."set".ucfirst($field->{name})."($pktype $field->{name}_)\n{\n\tthis.pk.$field->{name} = $field->{name}_;\n}\n\n");
			$methodCtx->print(tabalign("public $pktype", 32)."get".ucfirst($field->{name})."()\n{\n\treturn this.pk.$field->{name};\n}\n\n");
			$pk_methodCtx->print(tabalign("public void", 32)."set".ucfirst($field->{name})."($pktype $field->{name}_)\n{\n\tthis.$field->{name} = $field->{name}_;\n}\n\n");
			$pk_methodCtx->print(tabalign("public $pktype", 32)."get".ucfirst($field->{name})."()\n{\n\treturn this.$field->{name};\n}\n\n");
			$pkOrder .= ", \"".escapeString($field->{name})."\"";
			$use_pk = 1;
		}
		else {
			dr::Util::doDie("unknown field stype: $field->{name} -> $field->{stype}");
		}
	}
	if ($use_pk) {
		$javaOut->printSysimport("import javax.persistence.EmbeddedId;\n");
		$javaOut->printSysimport("import javax.persistence.Embeddable;\n");
		$javaOut->printSysimport("import java.io.Serializable;\n");
		$javaOut->printSysimport("import dr.meta.FieldOrder;\n");
		$pkCtx->print("\@FieldOrder(fields = { ".substr($pkOrder, 2)." })\n");
		$pkCtx->print("\@FieldRoles(".dr::prog::java::JavaGenerator::formatClassRoles($model).")\n");
		$pkCtx->print("\@Embeddable\npublic static class Pk implements Serializable\n{\n");
		$pkCtx->print("\t".tabalign("private static final long serialVersionUID", 32)."= 1L;\n\n");
		my $inpkCtx = $pk_endCtx->indentContext(1);
		$inpkCtx->print(tabalign("public", 32)."Pk()\n{\n}\n\n");
		$inpkCtx->print(tabalign("public", 32)."Pk(".join(", ", map({ $_->{stype} eq "compos" ? (convertPkType($_->getAssocTarget())." $_->{name}") : (dr::prog::java::JavaGenerator::mapJavaAttrType($_)." $_->{name}"); } @primary)).")\n");
		$inpkCtx->print("{\n");
		foreach my $pka (@primary) {
			$inpkCtx->print("\t"."this.$pka->{name} = $pka->{name};\n");
		}
		$inpkCtx->print("}\n\n");
		my $hash_cont = "0";
		my $equals_cont = "true";
		foreach my $pka (@primary) {
			my $java_type = $pka->{stype} eq "compos" ? "Compos" : dr::prog::java::JavaGenerator::mapJavaAttrType($pka);
			$hash_cont = "($hash_cont)*37+";
			$hash_cont .= dr::prog::java::JavaGenerator::isJavaTypePrimitive($java_type) ? "(int)$pka->{name}" : "($pka->{name} == null ? 0 : $pka->{name}.hashCode())";
			$equals_cont .= dr::prog::java::JavaGenerator::isJavaTypePrimitive($java_type) ? " && ($pka->{name} == s.$pka->{name})" : " && ($pka->{name} == null ? s.$pka->{name} == null : $pka->{name}.equals(s.$pka->{name}))";
		}
		$inpkCtx->print("\@Override\n".tabalign("public int", 32)."hashCode()\n{\n");
		$inpkCtx->print("\treturn $hash_cont;\n");
		$inpkCtx->print("}\n\n");
		$inpkCtx->print("\@Override\n".tabalign("public boolean", 32)."equals(Object o)\n{\n");
		$inpkCtx->print("\tif (!(o instanceof Pk))\n\t\treturn false;\n\tPk s = (Pk)o;\n");
		$inpkCtx->print("\treturn $equals_cont;\n");
		$inpkCtx->print("}\n\n");
		$pk_endCtx->print("};\n");
		$pk_endCtx->print("\n\@EmbeddedId\n".tabalign("protected Pk", 32)."pk = new Pk();\n\n");
		$methodCtx->print(tabalign("public Pk", 32)."getPk()\n{\n\treturn pk;\n}\n\n");
		$methodCtx->print(tabalign("public void", 32)."setPk(Pk pk_)\n{\n\tthis.pk = pk_;\n}\n\n");
		$pkClazz = "$classonly.Pk";
		$pkField = "pk";
		$pkDirect = 0;
	}
	$codeCtx->print("};\n");

	$javaOut->printSysimport("import dr.meta.ActionDefs;\n");
	$clsCtx->print("\@ActionDefs(actions = {\n");
	if (@{$model->{action_list}}) {
		$javaOut->printSysimport("import dr.meta.ActionDef;\n");
		my $actions = "";
		foreach my $action (@{$model->{action_list}}) {
			eval {
				my $atext = "name = \"".escapeString($action->{name})."\"";
				$atext .= ", isStatic = ".dr::prog::java::JavaGenerator::formatBoolean($action->isStatic())."";
				if (defined (my $formActioner = $action->checkDrTagValue("formActioner"))) {
					$atext .= ", formActioner = \"".escapeString($formActioner)."\"";
				}
				if (defined (my $formName = $action->checkDrTagValue("formName"))) {
					$atext .= ", formName = \"".escapeString($formName)."\"";
				}
				if (defined (my $guiDef = $action->checkDrTagValue("guiDef"))) {
					$atext .= ", guiDef = \"".escapeString($guiDef)."\"";
				}
				$atext .= ", roleAction = \"".escapeString($action->getDrTagValue("roleAction"))."\"";
				$clsCtx->print("\t\@ActionDef($atext),\n");
				1;
			}
				or dr::Util::doDie("failed to process $model->{full}.$action->{name}:\n$@");
		}
	}
	$clsCtx->print("})\n");

	if ($relations ne "") {
		$javaOut->printSysimport("import dr.meta.RelationDef;\n");
		$javaOut->printSysimport("import dr.meta.RelationDefs;\n");
		$clsCtx->print("\@RelationDefs(relations = {\n");
		$clsCtx->print($relations);
		$clsCtx->print("})\n");
	}

	{
		$javaOut->printSysimport("import dr.meta.KeyDef;\n");
		$clsCtx->print("\@KeyDef(pkDirect = ".dr::prog::java::JavaGenerator::formatBoolean($pkDirect).", pkClazz = ".(defined $pkClazz ? "$pkClazz.class" : "Object.class").", pkField = \"$pkField\", composPkClazz = ".($composPkClazz ? "$composPkClazz.class" : "Object.class").", pkComposField = \"".($pkComposField ? $pkComposField : "")."\", addPkFields = { $addPkFields })\n");
	}

	if ($fieldOrder) {
		$javaOut->printSysimport("import dr.meta.FieldOrder;\n");
		$clsCtx->print("\@FieldOrder(fields = { ".substr($fieldOrder, 2)." })\n");
	}
	else {
		$javaOut->printSysimport("import dr.meta.FieldOrder;\n");
		$clsCtx->print("\@FieldOrder(fields = { "." })\n");
	}
}

sub generateEntityBean($$$$)
{
	my $context			= shift;
	my $location			= shift;
	my $classname			= shift;
	my $more			= shift;

	my $jclassname = $classname; $jclassname =~ s/::/./g;
	my $filename = $jclassname; $filename =~ s/\./\//g;
	my $pkgname = $jclassname; $pkgname =~ s/\.\w+$//;
	my $classonly = $jclassname; $classonly =~ s/^.*\.//g;

	return if ($context->{processed}->{$filename});

	my $model = $context->{model_store}->loadModel($location, $classname);

	my $fdbean = $context->{file_trans}->updateChanged($context->{dst_dir}."/java/$filename.java");
	my $writer = $fdbean->rememberContext();
	$context->{processed}->{$filename} = 1;

	$writer->print("package $pkgname;\n");
	$writer->print("\n");
	my $sysimportCtx = $writer->subContext();
	$writer->print("\n");
	my $appimportCtx = $writer->subContext();

	$writer->print("\n\n");

	my $javaOut = dr::prog::java::JavaOutFileContext->new($context->{model_store}, $sysimportCtx, $appimportCtx, $writer);
	generateEntityBeanPart($context, $javaOut, $model);

	$context->{file_trans}->closeFile($fdbean);
}

sub generateOperParamList($)
{
	my $oper			= shift;

	return join(", ",
		map({
				my ( $ptype, $ptagger ) = $_->getFinalTypeWithTagger();
				($ptype->{stype} eq "primitive" ? dr::prog::java::JavaGenerator::mapJavaType($ptype) : convertToJavaClass($ptype->{full}))." $_->{name}"
			} @{$oper->{param_list}})
	);
}

sub translateUpdateRet($)
{
	my $oper = shift;

	my $retType = dr::prog::java::JavaGenerator::mapJavaType($oper->getReturnTypeWithTagger());
	my $proc;
	if ($retType eq "Boolean") {
		$retType = "boolean";
		$proc = " != 0";
	}
	elsif ($retType eq "Integer") {
		$retType = "int";
		$proc = "";
	}
	elsif ($retType eq "Long") {
		$retType = "long";
		$proc = "";
	}

	return ( $retType, $proc );
}

sub generateEntityDaoIf($$$$)
{
	my $context			= shift;
	my $location			= shift;
	my $classname			= shift;
	my $more			= shift;

	my $jbaseclassname = $classname; $jbaseclassname =~ s/::/./g;
	my $jclassname = $jbaseclassname."Dao";
	my $pkgname = $jclassname; $pkgname =~ s/\.\w+$//;
	my $classonly = $jclassname; $classonly =~ s/^.*\.//g;
	my $baseclassonly = $jbaseclassname; $baseclassonly =~ s/^.*\.//g;
	my $filename = "$pkgname.dao.${baseclassonly}Dao"; $filename =~ s/\./\//g;

	return if ($context->{processed}->{$filename});

	my $model = $context->{model_store}->loadModel($location, $classname);
	my $dao = $model->checkSubModel("${classname}::Dao");

	my $fddao = $context->{file_trans}->updateChanged($context->{dst_dir}."/java/$filename.java");
	$context->{processed}->{$filename} = 1;

	$fddao->print("package $pkgname.dao;\n\n");
	my $sysimportCtx = $fddao->rememberContext();
	my $importCtx = $fddao->rememberContext();
	$importCtx->printOnce("import $jbaseclassname;\n");

	$fddao->printIndented("\n\npublic interface $classonly\n{\n");
	$fddao->indent(1);
	my $methodCtx = $fddao->rememberContext();

	$methodCtx->print(tabalign("public $baseclassonly", 32)."loadByPk(".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk);\n");
	$methodCtx->print(tabalign("public List<$baseclassonly>", 32)."list();\n");
	$methodCtx->print(tabalign("public void", 32)."insert($baseclassonly obj);\n");
	$methodCtx->print(tabalign("public void", 32)."insertTxNew($baseclassonly obj);\n");
	$methodCtx->print(tabalign("public $baseclassonly", 32)."update($baseclassonly obj);\n");
	$methodCtx->print(tabalign("public void", 32)."remove($baseclassonly obj);\n");
	$methodCtx->print(tabalign("public boolean", 32)."removeByPk(".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk);\n");
	if (defined (my $compos = $model->checkCompos())) {
		$methodCtx->print(tabalign("public List<$baseclassonly>", 32)."listByCompos(".dr::prog::java::JavaGenerator::getPkTypeName($compos->getAssocTarget())." compos);\n");
		$methodCtx->print(tabalign("public long", 32)."removeByCompos(".(dr::prog::java::JavaGenerator::getPkTypeName($compos->getAssocTarget()))." compos);\n");
	}
	$methodCtx->print("\n");

	$sysimportCtx->printOnce("import java.util.Map;\n");
	$sysimportCtx->printOnce("import java.util.List;\n");
	$importCtx->printOnce("import dr.core.EntityHolder;\n");
	$importCtx->printOnce("import dr.core.AppContext;\n");

	$methodCtx->print(tabalign("public ".dr::prog::java::JavaGenerator::getPkTypeName($model), 32)."importDynamicKey(Map<String, Object> data);\n");
	$methodCtx->print(tabalign("public Map<String, Object>", 32)."exportDynamicData(EntityHolder<$baseclassonly> holder);\n");
	$methodCtx->print(tabalign("public Map<String, Object>", 32)."exportEntityData(EntityHolder<$baseclassonly> holder);\n");
	$methodCtx->print(tabalign("public $baseclassonly", 32)."createDynamic(EntityHolder<?> composition, Map<String, Object> data);\n");
	$methodCtx->print(tabalign("public EntityHolder<$baseclassonly>", 32)."retrieveDynamic(AppContext baseContext, ".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk);\n");
	$methodCtx->print(tabalign("public $baseclassonly", 32)."updateDynamic(EntityHolder<$baseclassonly> roleObject, ".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk, Map<String, Object> updates);\n");
	$methodCtx->print(tabalign("public boolean", 32)."deleteDynamic(AppContext roleContext, ".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk);\n");
	$methodCtx->print(tabalign("public long", 32)."listDynamic(List<EntityHolder<$baseclassonly>> results, EntityHolder<?> composition, Map<String, Object> filter, List<String> sorts, Long start, Long limit);\n");
	$methodCtx->print("\n");

	#$methodCtx->print("public Collection<EntityHolder<$baseclassonly>> list();\n\n");
	if ($dao) {
		for my $oper (grep({ $_->{name} =~ /^dr\.(\w+)\./ } @{$dao->{oper_list}})) {
			dr::Util::doDie("wrong name for dao operation: $oper->{name}") unless ($oper->{name} =~ m/^dr\.(\w+)\.(\w+)$/);
			my $optype = $1;
			my $opname = $2;
			if ($optype eq "code") {
				my $ret_type = translateJavaType($sysimportCtx, $model, $oper->getReturnTypeWithTagger());
				$methodCtx->print(tabalign("public $ret_type", 32)."$opname(".generateOperParamList($oper).");\n\n");
			}
			elsif ($optype eq "load") {
				$methodCtx->print(tabalign("public $baseclassonly", 32)."$opname(".generateOperParamList($oper).");\n\n");
			}
			elsif ($optype eq "list") {
				my $ret_type = translateJavaType($sysimportCtx, $model, $oper->getReturnTypeWithTagger());
				$methodCtx->print(tabalign("public $ret_type", 32)."$opname(".generateOperParamList($oper).");\n\n");
			}
			elsif ($optype eq "update") {
				my ( $retType, $proc ) = translateUpdateRet($oper);
				$methodCtx->print(tabalign("public $retType", 32)."$opname(".generateOperParamList($oper).");\n\n");
			}
			elsif ($optype eq "query") {
				$methodCtx->print(tabalign("public ".dr::prog::java::JavaGenerator::mapJavaType($oper->getReturnTypeWithTagger()), 32)."$opname(".generateOperParamList($oper).");\n\n");
			}
			else {
				dr::Util::doDie("$jbaseclassname.$oper->{name}: unknown dao operation type: $optype");
			}
		}
	}

	$fddao->indent(-1);
	$fddao->print("};\n");

	$context->{file_trans}->closeFile($fddao);
}

sub generateEntityDaoHib($$$$)
{
	my $context			= shift;
	my $location			= shift;
	my $classname			= shift;
	my $more			= shift;

	my $jbaseclassname = $classname; $jbaseclassname =~ s/::/./g;
	my $jclassname = $jbaseclassname."DaoHib";
	my $filename = $jclassname; $filename =~ s/\./\//g;
	my $pkgbase = $jclassname; $pkgbase =~ s/\.\w+$//;
	my $pkgname = $jclassname; $pkgname =~ s/\.\w+$//; $pkgname .= ".perhib";
	my $classonly = $jclassname; $classonly =~ s/^.*\.//g;
	my $baseclassonly = $jbaseclassname; $baseclassonly =~ s/^.*\.//g;

	return if ($context->{processed}->{$filename});

	my $model = $context->{model_store}->loadModel($location, $classname);
	my $dao = $model->checkSubModel("${classname}::Dao");

	my $fddao = $context->{file_trans}->updateChanged($context->{dst_dir}."/java".dr::Util::prependFile("/$filename.java", "perhib/"));
	$context->{processed}->{$filename} = 1;

	$fddao->print("package $pkgname;\n\n");
	my $sysimportCtx = $fddao->rememberContext();
	$sysimportCtx->printOnce("import $jbaseclassname;\n");
	$sysimportCtx->printOnce("import org.hibernate.SessionFactory;\n");
	$sysimportCtx->printOnce("import org.springframework.orm.hibernate3.HibernateTemplate;\n");
	$sysimportCtx->printOnce("import org.springframework.stereotype.Repository;\n");
	$sysimportCtx->printOnce("import org.springframework.transaction.annotation.Propagation;\n");
	$sysimportCtx->printOnce("import org.springframework.transaction.annotation.Transactional;\n");

	my $importCtx = $fddao->rememberContext();

	$fddao->printIndented("\n\n\@Repository\n\@Transactional(readOnly = true)\npublic class $classonly extends dr.core.ContextDao implements $pkgbase.dao.${baseclassonly}Dao\n{\n");
	$fddao->indent(1);
	my $fieldCtx = $fddao->rememberContext();
	$fddao->printIndented("\n");
	my $methodCtx = $fddao->rememberContext();

	$fddao->printAt($fieldCtx, tabalign("protected HibernateTemplate", 32)."template = null;\n\n");

	$fddao->printAt($methodCtx, tabalign("public void", 32)."setSessionFactory(SessionFactory sessionFactory)\n{\ttemplate = new HibernateTemplate(sessionFactory);\n}\n\n");

	$methodCtx->print("\@Transactional(readOnly = true, propagation = Propagation.REQUIRED)\n".tabalign("public $baseclassonly", 32)."loadByPk(".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk)\n{\n\tthrow new RuntimeException(\"unsupported\"); /*return template.bulkUpdate(\"FROM $baseclassonly WHERE ".dr::prog::java::JavaGenerator::getPkFieldName($model)." = ?\", pk); */\n}\n\n");
	$methodCtx->print("\@Transactional(readOnly = true, propagation = Propagation.REQUIRED)\n".tabalign("public $baseclassonly", 32)."list()\n{\n\tthrow new RuntimeException(\"unsupported\"); /*return template.bulkUpdate(\"FROM $baseclassonly WHERE ".dr::prog::java::JavaGenerator::getPkFieldName($model)." = ?\", pk); */\n}\n\n");
	$methodCtx->print("\@Transactional(readOnly = false, propagation = Propagation.REQUIRED)\n".tabalign("public void", 32)."insert($baseclassonly obj)\n{\n\ttemplate.saveOrUpdate(obj);\n}\n\n");
	$methodCtx->print("\@Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)\n".tabalign("public void", 32)."insertTxNew($baseclassonly obj)\n{\n\ttemplate.saveOrUpdate(obj);\n}\n\n");
	$methodCtx->print("\@Transactional(readOnly = false, propagation = Propagation.REQUIRED)\n".tabalign("public $baseclassonly", 32)."update($baseclassonly obj)\n{\n\ttemplate.saveOrUpdate(obj);\n}\n\n");
	$methodCtx->print("\@Transactional(readOnly = false, propagation = Propagation.REQUIRED)\n".tabalign("public void", 32)."remove($baseclassonly obj)\n{\n\ttemplate.delete(obj);\n}\n\n");
	$methodCtx->print("\@Transactional(readOnly = false, propagation = Propagation.REQUIRED)\n".tabalign("public boolean", 32)."removeByPk(".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk)\n{\n\treturn template.bulkUpdate(\"DELETE FROM $baseclassonly WHERE ".dr::prog::java::JavaGenerator::getPkFieldName($model)." = ?\", pk) != 0;\n}\n\n");

	$sysimportCtx->printOnce("import java.util.Map;\n");
	$sysimportCtx->printOnce("import java.util.List;\n");
	$importCtx->printOnce("import dr.core.EntityHolder;\n");
	$importCtx->printOnce("import dr.core.AppContext;\n");

	$methodCtx->print(tabalign("public ".dr::prog::java::JavaGenerator::getPkTypeName($model), 32)."importDynamicKey(Map<String, Object> data) { throw new UnsupportedOperationException(\"hibernate dao do not support dynamic operations\"); }\n");
	$methodCtx->print(tabalign("public Map<String, Object>", 32)."exportDynamicData(EntityHolder<$baseclassonly> holder) { throw new UnsupportedOperationException(\"hibernate dao do not support dynamic operations\"); }\n");
	$methodCtx->print(tabalign("public Map<String, Object>", 32)."exportEntityData(EntityHolder<$baseclassonly> holder) { throw new UnsupportedOperationException(\"hibernate dao do not support dynamic operations\"); }\n");
	$methodCtx->print(tabalign("public $baseclassonly", 32)."createDynamic(EntityHolder<?> composition, Map<String, Object> data) { throw new UnsupportedOperationException(\"hibernate dao do not support dynamic operations\"); }\n");
	$methodCtx->print(tabalign("public EntityHolder<$baseclassonly>", 32)."retrieveDynamic(AppContext baseContext, ".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk) { throw new UnsupportedOperationException(\"hibernate dao do not support dynamic operations\"); }\n");
	$methodCtx->print(tabalign("public $baseclassonly", 32)."updateDynamic(EntityHolder<$baseclassonly> roleObject, ".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk, Map<String, Object> updates) { throw new UnsupportedOperationException(\"hibernate dao do not support dynamic operations\"); }\n");
	$methodCtx->print(tabalign("public boolean", 32)."deleteDynamic(AppContext roleContext, ".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk) { throw new UnsupportedOperationException(\"hibernate dao do not support dynamic operations\"); }\n");
	$methodCtx->print(tabalign("public long", 32)."listDynamic(List<EntityHolder<$baseclassonly>> results, EntityHolder<?> composition, Map<String, Object> filter, List<String> sorts, Long start, Long limit) { throw new UnsupportedOperationException(\"hibernate dao do not support dynamic operations\"); }\n");
	$methodCtx->print("\n");

	#$fddao->printAt($methodCtx, "\@SuppressWarnings(\"unchecked\")\n".tabalign("public Collection<EntityHolder<$baseclassonly>>", 32)."list()\n{\n\tCollection<EntityHolder<$baseclassonly>> result = new LinkedList<EntityHolder<$baseclassonly>>();\n\tfor ($baseclassonly obj: (Collection<$baseclassonly>)template.find(\"from $baseclassonly\")) {\n\t\tresult.add(new EntityHolder<$baseclassonly>(obj, role));\n\t}\n\treturn result;\n}\n\n");
	if ($dao) {
		for my $oper (grep({ $_->{name} =~ /^dr\.(\w+)\./ } @{$dao->{oper_list}})) {
			dr::Util::doDie("wrong name for dao operation: $oper->{name}") unless ($oper->{name} =~ m/^dr\.(\w+)\.(\w+)$/);
			my $optype = $1;
			my $opname = $2;
			if ($optype eq "load") {
				if (0) {
					$sysimportCtx->printOnce("import dr.core.EntityHolder;\n");
					$sysimportCtx->printOnce("import java.util.List;\n");
					$methodCtx->print(tabalign("\@SuppressWarnings(\"unchecked\")\npublic EntityHolder<$baseclassonly>", 32)." $opname(".generateOperParamList($oper).")\n{\n");
					my $contCtx = $methodCtx->indentContext(1);
					my $sql = "";
					my $cond = "";
					my $list = "";
					if (defined ($sql = $oper->checkDrTagValue("jql"))) {
						while ($sql =~ m/^(.*?):(\w+)(.*?)$/s) {
							$sql = "$1?$3";
							$list .= ", $2";
						}
					}
					else {
						foreach my $param (@{$oper->{param_list}}) {
							$cond .= " AND $param->{name} = ?";
							$list .= ", $param->{name}";
						}
						$cond = substr($cond, 5);
						$sql = "FROM $baseclassonly WHERE $cond";
					}
					$contCtx->print("List<$baseclassonly> result = template.find(\"".escapeString($sql)."\"$list);\n");
					$contCtx->print("if (result.size() == 0)\n\treturn null;\n");
					$contCtx->print("return new EntityHolder<$baseclassonly>(result.get(0), null);\n");
					$methodCtx->print("}\n\n");
				}
				else {
					$sysimportCtx->printOnce("import java.util.List;\n");
					$methodCtx->print(tabalign("public $baseclassonly", 32)." $opname(".generateOperParamList($oper).")\n{\n");
					my $contCtx = $methodCtx->indentContext(1);
					my $sql = "";
					my $cond = "";
					my $list = "";
					if (defined ($sql = $oper->checkDrTagValue("jql"))) {
						while ($sql =~ m/^(.*?):(\w+)(.*?)$/s) {
							$sql = "$1?$3";
							$list .= ", $2";
						}
					}
					else {
						foreach my $param (@{$oper->{param_list}}) {
							$cond .= " AND $param->{name} = ?";
							$list .= ", $param->{name}";
						}
						$cond = substr($cond, 5);
						$sql = "FROM $baseclassonly WHERE $cond";
					}
					$contCtx->print("\@SuppressWarnings(\"unchecked\")\nList<$baseclassonly> result = template.find(\"".escapeString($sql)."\"$list);\n");
					$contCtx->print("if (result.size() == 0)\n\treturn null;\n");
					$contCtx->print("return result.get(0);\n");
					$methodCtx->print("}\n\n");
				}
			}
			elsif ($optype eq "list") {
				my $ret_type = translateJavaType($sysimportCtx, $model, $oper->getReturnTypeWithTagger());
				$methodCtx->print(tabalign("public $ret_type", 32)."$opname(".generateOperParamList($oper).")\n{\n");
				my $sql = $oper->getDrTagValue("jql");
				my $cond = "";
				my $list = "";
				while ($sql =~ m/^(.*?):(\w+)(.*?)$/s) {
					$sql = "$1?$3";
					$list .= ", $2";
				}
				$methodCtx->print("\t\@SuppressWarnings(\"unchecked\")\n\t$ret_type result = ($ret_type)template.find(\"".escapeString($sql)."\"$list);\n");
				$methodCtx->print("\treturn result;\n");
				$methodCtx->print("}\n\n");
			}
			elsif ($optype eq "update") {
				my $retType = dr::prog::java::JavaGenerator::mapJavaType($oper->getReturnTypeWithTagger());
				$methodCtx->print(tabalign("public $retType", 32)."$opname(".generateOperParamList($oper).")\n{\n");
				my $sql = $oper->getDrTagValue("jql");
				my $cond = "";
				my $list = "";
				while ($sql =~ m/^(.*?):((\w+\.)*\w+(\(\))?)(.*?)$/s) {
					$sql = "$1?$5";
					$list .= ", $2";
				}
				$methodCtx->print("\ttemplate.bulkUpdate(\"".escapeString($sql)."\"$list);\n");
				$methodCtx->print("}\n\n");
			}
			elsif ($optype eq "query") {
				my $ret_type = dr::prog::java::JavaGenerator::mapJavaType($oper->getReturnTypeWithTagger());
				$methodCtx->print(tabalign("public $ret_type", 32)."$opname(".generateOperParamList($oper).")\n{\n");
				my $sql = $oper->getDrTagValue("jql");
				my $cond = "";
				my $list = "";
				while ($sql =~ m/^(.*?):(\w+(\(\))?)(.*?)$/s) {
					$sql = "$1?$4";
					$list .= ", $2";
				}
				$sysimportCtx->printOnce("import java.util.List;\n");
				$methodCtx->print("\t\@SuppressWarnings(\"rawtypes\")\n\tList result = template.find(\"".escapeString($sql)."\"$list);\n");
				$methodCtx->print("\treturn result.size() == 0 ? null : ($ret_type)result.get(0);\n");
				$methodCtx->print("}\n\n");
			}
			else {
				dr::Util::doDie("$jbaseclassname.$oper->{name}: unknown dao operation type: $optype");
			}
		}
	}

	$fddao->indent(-1);
	$fddao->print("};\n");

	$context->{file_trans}->closeFile($fddao);
}

sub getEjbTransactionParams($$$)
{
	my $oper			= shift;
	my $readOnly_dfl		= shift;
	my $propagation_dfl		= shift;

	my $readOnly = $oper->checkDrTagValue("readOnly") // $readOnly_dfl;
	my $propagation = $oper->checkDrTagValue("propagation") // $propagation_dfl;
	my $args = "";
	#$args .= ", readOnly = ".(convertBool($readOnly) ? "true" : "false") if ($readOnly ne "");
	#$args .= ", propagation = Propagation.$propagation" if ($propagation);
	$args .= ", TransactionAttributeType.$propagation" if ($propagation);
	my $transactionUnit = "\@Transactional(\"".getDataSource($oper->{owner})."\")\n";
	return ($args ? "\@TransactionAttribute(".substr($args, 2).")\n" : "").
		$transactionUnit;
}

sub replaceJqlParams($)
{
	my $oper			= shift;

	my $sql = $oper->getDrTagValue("jql");
	my $list = "";
	my $i = 0;
	while ($sql =~ m/^(.*?):((\w+\.)*\w+(\(\))?)(.*?)$/s) {
		++$i;
		$sql = "$1?$i$5";
		$list .= ".setParameter($i, $2)";
	}
	return ( $sql, $list );
}

sub generateEntityDaoJpa($$$$)
{
	my $context			= shift;
	my $location			= shift;
	my $classname			= shift;
	my $more			= shift;

	my $jbaseclassname = $classname; $jbaseclassname =~ s/::/./g;
	my $jclassname = $jbaseclassname."DaoJpa";
	my $filename = $jclassname; $filename =~ s/\./\//g;
	my $pkgbase = $jclassname; $pkgbase =~ s/\.\w+$//;
	my $pkgname = $jclassname; $pkgname =~ s/\.\w+$//; $pkgname .= ".perjpa";
	my $classonly = $jclassname; $classonly =~ s/^.*\.//g;
	my $baseclassonly = $jbaseclassname; $baseclassonly =~ s/^.*\.//g;

	return if ($context->{processed}->{$filename});

	my $model = $context->{model_store}->loadModel($location, $classname);
	my $dao = $model->checkSubModel("${classname}::Dao");

	my $fddao = $context->{file_trans}->updateChanged($context->{dst_dir}."/java".dr::Util::prependFile("/$filename.java", "perjpa/"));
	$context->{processed}->{$filename} = 1;

	$fddao->print("package $pkgname;\n\n");
	my $sysimportCtx = $fddao->rememberContext();
	$sysimportCtx->printOnce("import $jbaseclassname;\n");
	$sysimportCtx->printOnce("import javax.persistence.EntityManager;\n");
	$sysimportCtx->printOnce("import javax.persistence.PersistenceContext;\n");
	#$sysimportCtx->printOnce("import javax.persistence.PersistenceUnit;\n");
	$sysimportCtx->printOnce("import javax.ejb.TransactionAttribute;\n");
	$sysimportCtx->printOnce("import javax.ejb.TransactionAttributeType;\n");
	$sysimportCtx->printOnce("import org.springframework.stereotype.Repository;\n");
	#$sysimportCtx->printOnce("import org.springframework.transaction.annotation.Propagation;\n");
	$sysimportCtx->printOnce("import org.springframework.transaction.annotation.Transactional;\n");

	my $importCtx = $fddao->rememberContext();

	my $transactionUnit = "\@Transactional(\"".getDataSource($dao || $model)."\")\n";

	$fddao->printIndented("\n\n\@Repository\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.SUPPORTS)\npublic class $classonly extends dr.core.ContextDao implements $pkgbase.dao.${baseclassonly}Dao\n{\n");
	$fddao->indent(1);
	my $fieldCtx = $fddao->rememberContext();
	$fddao->printIndented("\n");
	my $methodCtx = $fddao->rememberContext();

	$fddao->printAt($fieldCtx, "\@PersistenceContext(unitName=\"".getDataSource($dao || $model)."\")\n");
	#$fddao->printAt($fieldCtx, "\@PersistenceUnit(name=\"".getDataSource($dao || $model)."\")\n");
	$fddao->printAt($fieldCtx, tabalign("protected EntityManager", 32)."em;\n\n");

	$importCtx->printOnce("import dr.dao.RoleDaoAccessJpa;\n");
	$fieldCtx->print(tabalign("protected RoleDaoAccessJpa<$baseclassonly>", 32)."roleDaoAccess;\n\n");
	$methodCtx->print(tabalign("public RoleDaoAccessJpa<$baseclassonly>", 32)."getRoleDaoAccess()\n{\n\tif (roleDaoAccess == null)\n\t\troleDaoAccess = new RoleDaoAccessJpa<$baseclassonly>($baseclassonly.class, em);\n\treturn roleDaoAccess;\n}\n\n");

	$methodCtx->print("\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public $baseclassonly", 32)."loadByPk(".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk)\n{\n\treturn ($baseclassonly)em.find($baseclassonly.class, pk);\n}\n\n");
	$methodCtx->print("\@SuppressWarnings(\"unchecked\")\n\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public List<$baseclassonly>", 32)."list()\n{\n\treturn (List<$baseclassonly>)em.createQuery(\"FROM $baseclassonly ORDER BY ".dr::prog::java::JavaGenerator::getPkFieldName($model)."\").getResultList();\n}\n\n");
	$methodCtx->print("\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public void", 32)."insert($baseclassonly obj)\n{\n\tem.persist(obj);\n\tem.flush();\n}\n\n");
	$methodCtx->print("\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRES_NEW)\n".tabalign("public void", 32)."insertTxNew($baseclassonly obj)\n{\n\tem.persist(obj);\n\tem.flush();\n}\n\n");
	$methodCtx->print("\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public $baseclassonly", 32)."update($baseclassonly obj)\n{\n\tobj = em.merge(obj);\n\tem.flush();\n\treturn obj;\n}\n\n");
	$methodCtx->print("\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public void", 32)."remove($baseclassonly obj)\n{\n\tem.remove(obj);\n\tem.flush();\n}\n\n");
	$methodCtx->print("\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public boolean", 32)."removeByPk(".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk)\n{\n\treturn em.createQuery(\"DELETE FROM $baseclassonly obj WHERE obj.".dr::prog::java::JavaGenerator::getPkFieldName($model)." = ?1\").setParameter(1, pk).executeUpdate() != 0;\n}\n\n");
	if (defined (my $compos = $model->checkCompos())) {
		$methodCtx->print("\@SuppressWarnings(\"unchecked\")\n\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public List<$baseclassonly>", 32)."listByCompos(".dr::prog::java::JavaGenerator::getPkTypeName($compos->getAssocTarget())." compos)\n{\n\treturn (List<$baseclassonly>)em.createQuery(\"FROM $baseclassonly WHERE ".$compos->{name}." = ?1 ORDER BY ".dr::prog::java::JavaGenerator::getPkFieldName($model)."\").setParameter(1, compos).getResultList();\n}\n\n");
		$methodCtx->print("\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public long", 32)."removeByCompos(".dr::prog::java::JavaGenerator::getPkTypeName($compos->getAssocTarget())." compos)\n{\n\treturn em.createQuery(\"DELETE FROM $baseclassonly obj WHERE obj.pk.".$compos->{name}." = ?1\").setParameter(1, compos).executeUpdate();\n}\n\n");
	}

	$sysimportCtx->printOnce("import java.util.Map;\n");
	$sysimportCtx->printOnce("import java.util.List;\n");
	$importCtx->printOnce("import dr.core.EntityHolder;\n");
	$importCtx->printOnce("import dr.core.AppContext;\n");

	$methodCtx->print(tabalign("public ".dr::prog::java::JavaGenerator::getPkTypeName($model), 32)."importDynamicKey(Map<String, Object> data)\n{\n\treturn (".dr::prog::java::JavaGenerator::getPkTypeName($model).")getRoleDaoAccess().importDynamicKey(data);\n}\n\n");
	$methodCtx->print(tabalign("public Map<String, Object>", 32)."exportDynamicData(EntityHolder<$baseclassonly> holder)\n{\n\treturn getRoleDaoAccess().exportDynamicData(holder);\n}\n\n");
	$methodCtx->print(tabalign("public Map<String, Object>", 32)."exportEntityData(EntityHolder<$baseclassonly> holder)\n{\n\treturn getRoleDaoAccess().exportEntityData(holder);\n}\n\n");
	$methodCtx->print("\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public $baseclassonly", 32)."createDynamic(EntityHolder<?> composition, Map<String, Object> data)\n{\n\treturn getRoleDaoAccess().createObject(composition, data);\n}\n\n");
	$methodCtx->print(tabalign("public EntityHolder<$baseclassonly>", 32)."retrieveDynamic(AppContext baseContext, ".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk)\n{\n\treturn getRoleDaoAccess().retrieveObject(baseContext, pk);\n}\n\n");
	$methodCtx->print("\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public $baseclassonly", 32)."updateDynamic(EntityHolder<$baseclassonly> roleObject, ".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk, Map<String, Object> updates)\n{\n\treturn getRoleDaoAccess().updateObject(roleObject, pk, updates);\n}\n\n");
	$methodCtx->print("\@Override\n$transactionUnit\@TransactionAttribute(TransactionAttributeType.REQUIRED)\n".tabalign("public boolean", 32)."deleteDynamic(AppContext roleContext, ".dr::prog::java::JavaGenerator::getPkTypeName($model)." pk)\n{\n\treturn getRoleDaoAccess().deleteObject(roleContext, pk);\n}\n\n");
	$methodCtx->print(tabalign("public long", 32)."listDynamic(List<EntityHolder<$baseclassonly>> results, EntityHolder<?> composition, Map<String, Object> filter, List<String> sorts, Long start, Long limit)\n{\n\treturn getRoleDaoAccess().listObjects(results, composition, filter, sorts, start, limit);\n}\n\n");

	$methodCtx->print("\n");

	if ($dao) {
		for my $oper (grep({ $_->{name} =~ /^dr\.(\w+)\./ } @{$dao->{oper_list}})) {
			dr::Util::doDie("wrong name for dao operation: $oper->{name}") unless ($oper->{name} =~ m/^dr\.(\w+)\.(\w+)$/);
			my $optype = $1;
			my $opname = $2;
			if ($optype eq "code") {
				my $ret_type = translateJavaType($sysimportCtx, $model, $oper->getReturnTypeWithTagger());
				$methodCtx->print("\@Override\n".getEjbTransactionParams($oper, 0, "REQUIRED").tabalign("public $ret_type", 32)."$opname(".generateOperParamList($oper).")\n{\n");
				$methodCtx->print(indentString(makeLineEnd($oper->getDrTagValue("code")), "\t"));
				$methodCtx->print("}\n\n");
			}
			elsif ($optype eq "load") {
				$sysimportCtx->printOnce("import java.util.List;\n");
				$methodCtx->print("\@Override\n".getEjbTransactionParams($oper, 0, "REQUIRED").tabalign("public $baseclassonly", 32)."$opname(".generateOperParamList($oper).")\n{\n");
				my $contCtx = $methodCtx->indentContext(1);
				my $sql = "";
				my $list = "";
				if (defined ($sql = $oper->checkDrTagValue("jql"))) {
					$sql = replaceJqlParams($oper);
					( $sql, $list ) = replaceJqlParams($oper);
				}
				else {
					my $cond = "";
					my $i = 0;
					foreach my $param (@{$oper->{param_list}}) {
						++$i;
						$cond .= " AND $param->{name} = ?$i";
						$list .= ".setParameter($i, $param->{name})";
					}
					$cond = substr($cond, 5);
					$sql = "FROM $baseclassonly WHERE $cond";
				}
				$contCtx->print("\@SuppressWarnings(\"unchecked\")\nList<$baseclassonly> result = em.createQuery(\"".escapeString($sql)."\")$list.getResultList();\n");
				$contCtx->print("if (result.size() == 0)\n\treturn null;\n");
				$contCtx->print("return result.get(0);\n");
				$methodCtx->print("}\n\n");
			}
			elsif ($optype eq "list") {
				my $ret_type = translateJavaType($sysimportCtx, $model, $oper->getReturnTypeWithTagger());
				$methodCtx->print("\@Override\n".getEjbTransactionParams($oper, 0, "REQUIRED").tabalign("public $ret_type", 32)."$opname(".generateOperParamList($oper).")\n{\n");
				my ( $sql, $list ) = replaceJqlParams($oper);
				$methodCtx->print("\t\@SuppressWarnings(\"unchecked\")\n\t$ret_type result = ($ret_type)em.createQuery(\"".escapeString($sql)."\")$list.getResultList();\n");
				$methodCtx->print("\treturn result;\n");
				$methodCtx->print("}\n\n");
			}
			elsif ($optype eq "update") {
				my ( $retType, $proc ) = translateUpdateRet($oper);
				$methodCtx->print("\@Override\n".getEjbTransactionParams($oper, 0, "REQUIRED").tabalign("public $retType", 32)."$opname(".generateOperParamList($oper).")\n{\n");
				my ( $sql, $list ) = replaceJqlParams($oper);
				$methodCtx->print("\t".(defined $proc ? "return " : "")."em.createQuery(\"".escapeString($sql)."\")$list.executeUpdate()".(defined $proc ? $proc : "").";\n");
				$methodCtx->print("}\n\n");
			}
			elsif ($optype eq "query") {
				my $ret_type = dr::prog::java::JavaGenerator::mapJavaType($oper->getReturnTypeWithTagger());
				$methodCtx->print("\@Override\n".getEjbTransactionParams($oper, 0, "REQUIRED").tabalign("public $ret_type", 32)."$opname(".generateOperParamList($oper).")\n{\n");
				my ( $sql, $list ) = replaceJqlParams($oper);
				$sysimportCtx->printOnce("import java.util.List;\n");
				$methodCtx->print("\t\@SuppressWarnings(\"rawtypes\")\n\tList result = em.createQuery(\"".escapeString($sql)."\")$list.getResultList();\n");
				$methodCtx->print("\treturn result.size() == 0 ? null : ($ret_type)result.get(0);\n");
				$methodCtx->print("}\n\n");
			}
			else {
				dr::Util::doDie("$jbaseclassname.$oper->{name}: unknown dao operation type: $optype");
			}
		}
	}

	$fddao->indent(-1);
	$fddao->print("};\n");

	$context->{file_trans}->closeFile($fddao);
}

sub generateFile($$$$)
{
	my $context			= shift;
	my $location			= shift;
	my $classname			= shift;
	my $gens			= shift;

	foreach my $gen (@$gens) {
		$gen =~ m/^(\w+)(:(.*))?$/
			or dr::Util::doDie("failed to match gen element to word(:options)?: $gen");
		$gen = $1; my $more = $2;
		if ($gen eq "entbean") {
			generateEntityBean($context, $location, $classname, $more);
		}
		elsif ($gen eq "daoif") {
			generateEntityDaoIf($context, $location, $classname, $more);
		}
		elsif ($gen eq "daojpa") {
			generateEntityDaoJpa($context, $location, $classname, $more);
		}
		elsif ($gen eq "daohib") {
			generateEntityDaoHib($context, $location, $classname, $more);
		}
		else {
			dr::Util::doDie("unknown gen identifier '$gen' for $classname");
		}
	}
}

sub runFile($$$$)
{
	my $model_store		= shift;
	my $src_dir		= shift;
	my $dst_dir		= shift;
	my $relname		= shift;

	my $err = eval {
		my $processor;
		if ($relname =~ m/\.java$/) {
			$processor = dr::prog::java::JavaGenerator->new($file_trans, $model_store, $dst_dir, $src_dir, $relname);
		}
		else {
			$processor = dr::prog::gen::CopyGenerator->new($file_trans, $model_store, $dst_dir, $src_dir, $relname);
		}
		$processor->process()
			or $file_trans->flush(), 0;
	};
	unless (defined $err) {
		STDERR->print("$src_dir/$relname:0: fatal error occurred: $@");
		return 1;
	}
	return $err;
}

sub runDirectories($$)
{
	my $src_dir		= shift;
	my $dst_dir		= shift;

	$src_dir .= "/" unless ($src_dir =~ m,/$,);
	$dst_dir .= "/" unless ($dst_dir =~ m,/$,);
	my @files;
	find({
			no_chdir		=> 1,
			wanted			=> sub {
				if (m/^(\.\/)?(.*\/|)(.*)\.(java|xml|properties|sql)$/) {
					push(@files, $_);
				}
			},
			preprocess		=> sub {
				return unless ($File::Find::dir eq $src_dir || $File::Find::dir."/" eq $src_dir || $File::Find::dir =~ m,^(.*/)(\w+)$,);
				return @_;
			},
		}, $src_dir);

	my $model_store = dr::ModelStore->new($opts{m});

	my $context = {
		file_trans		=> $file_trans,
		src_dir			=> $src_dir,
		dst_dir			=> $dst_dir,
		processed		=> {},
		model_store		=> $model_store,
	};

	foreach my $fullname (@files) {
		die "wrong name: $fullname" unless (substr($fullname, 0, length($src_dir)) eq $src_dir);
		my $relname = substr($fullname, length($src_dir));
		my $src_mtime = (stat("$src_dir$relname"))[9];
		my $dst_mtime = (stat("$dst_dir$relname"))[9];
		next if (defined $dst_mtime && $src_mtime <= $dst_mtime);
		$dst_mtime = "-" unless (defined $dst_mtime);
		STDERR->print("generate from $src_dir$relname: $src_mtime $dst_mtime\n");
		if ((my $err = runFile($model_store, $src_dir, $dst_dir, $relname)) != 0) {
			return $err;
		}
	}

	if (defined $opts{l}) {
		my $fdlist = FileHandle->new("$opts{l}", "<")
			or die "failed to open $opts{l}: $!";
		while (<$fdlist>) {
			chomp;
			s/\s*(|#.*)$//;
			next unless (length($_));
			m/^(\S+)\s+(\S+)\s+(.*)$/
				or die "gen line does not match 'location class gens': $_";
			my $location = $1;
			my $classname = $2;
			my @gens = split(/\s+/, $3);
			$classname =~ s/\./::/g;
			generateFile($context, $location, $classname, \@gens);
		}
	}

	return 0;
}


getopts('dm:l:', \%opts)
	or exit(2);

$file_trans = dr::FileTransaction->new();
my $err;

if ($opts{d}) {
	die "Usage (dir): $0 -d src-dir dst-dir" unless (@ARGV == 2);
	$err = runDirectories($ARGV[0], $ARGV[1]);
}
else {
	die "Usage (file): $0 src-dir dst-dir file" unless (@ARGV == 3);
	$err = runFile(dr::ModelStore->new($opts{m}), $ARGV[0], $ARGV[1], $ARGV[2]);
}

if ($err == 0) {
	$file_trans->commit();
}
undef $file_trans;
exit($err);
