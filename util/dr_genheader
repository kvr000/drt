#!/usr/bin/perl

package dr::GenHeader::FileTransaction;

use strict;
use warnings;

sub new
{
	my $class = shift; $class = ref($class) || $class;

	return bless { opers => [] }, $class;
}

sub commit
{
	my $this		= shift;
	$this->{opers} = [];
}

sub addCreated
{
	my $this		= shift;
	my $fname		= shift;

	push(@{$this->{opers}}, { op => "rm", name => $fname });
}

sub DESTROY
{
	my $this		= shift;

	foreach my $op (@{$this->{opers}}) {
		if ($op->{op} eq "rm") {
			unlink($op->{name});
		}
		else {
			die "unsupported operation: $op->{op}";
		}
	}
}


package main;

use strict;
use warnings;

use FileHandle;
use Data::Dumper;

sub fileToHeader($$)
{
	my $ns			= shift;
	my $file		= shift;

	$file =~ s/.*\///;
	$file =~ s/\./__/g;
	$ns =~ s/::/__/g;
	return "${ns}__${file}__";
}

sub nsToMacro($)
{
	my $ns			= shift;
	$ns =~ s/::/_/g;
	$ns = uc($ns);
	return "${ns}_NS";
}

sub nsToMacroBegin($)
{
	return nsToMacro(shift)."_BEGIN";
}

sub nsToMacroEnd($)
{
	return nsToMacro(shift)."_END";
}

sub formatMethodDecl($$)
{
	my $ret			= shift;
	my $decl		= shift;

	my $full = $ret;
	if (length($ret) < 32) {
		$full .= "\t"x((39-length($ret))/8);
	}
	else {
		$full .= " ";
	}
	$full .= $decl;
	return $full;
}

sub readContent($$$)
{
	my $fd			= shift;
	my $lineno		= shift;
	my $fin			= shift;

	my $cont = "";

	while (<$fd>) {
		$$lineno++;
		if (m/^\s*\*\*\//s) {
			die "didn't find close $fin block";
		}
		elsif (m/^\s*\*\s?$fin\s*$/s) {
			return $cont;
		}
		elsif (m/^\s*\* ?(.*)$/s) {
			$cont .= $1;
		}
		else {
			die "unexpected content";
		}
	}
	die "didn't find close $fin block";
}


die "Usage: $0 cxx_file gen_file_base" unless (@ARGV == 2);
my $cxxname = shift(@ARGV);
die "passed file does not end with suffix .cxx" unless ($cxxname =~ m/(.*)\.cxx$/);
my $basename = shift(@ARGV);
my $hxxname = "$basename.hxx";
my $defname = "$basename-def.hxx";

our $file_trans = dr::GenHeader::FileTransaction->new();

our $cxx = FileHandle->new($cxxname, "<")
	or die "failed to open $cxxname: $!";
our $hxx = FileHandle->new($hxxname, ">")
	or die "failed to open $hxxname: $!";
$file_trans->addCreated($hxxname);
our $def = FileHandle->new($defname, ">")
	or die "failed to open $defname: $!";
$file_trans->addCreated($defname);

our @cl_list;

our @includes = ();
our $ns;
our @ns_use = ();
our @forwards = ();

sub printIndented($$$)
{
	my $fd			= shift;
	my $level		= shift;
	my $text		= shift;

	if ($level > 0) {
		my $ind = "\t" x $level;
		$text =~ s/^(.)/$ind$1/gm;
	}
	$fd->print($text);
}

sub printClass($$);
sub printClass($$)
{
	my $cld			= shift;
	my $level		= shift;

	my $iname= $cld->{class};
	for (my $i = 0; $i < $level; $i++) {
		$iname =~ s/^\w*:://;
	}

	for (my $i = 0; ; $i++) {
		splice(@cl_list, $i, 1), last if ($cl_list[$i] == $cld);
	}

	die "$cxxname:$cld->{defline}: class $cld->{class} has no ancestor" if ($cld->{type} ne "struct" && !defined $cld->{ancestor});

	if ($cld->{type} eq "object") {
		printIndented($hxx, $level, sprintf("%s %s: public %s\n{\n", "class", $iname, $cld->{ancestor}));
		printIndented($hxx, $level, sprintf("\tDR_OBJECT_DECL_SIMPLE(%s, %s);\n", $iname, $cld->{ancestor}));
		$def->printf("\n");
		$def->printf("DR_OBJECT_IMPL_IFACE%d(%s%s);\n", scalar @{$cld->{ifaces}}, $cld->{class}, join("", map({ ", $_" } @{$cld->{ifaces}})));
		$def->printf("DR_OBJECT_DEF(%s_STR, %s, %s);\n", nsToMacro($ns), $cld->{class}, $cld->{ancestor});
	}
	elsif ($cld->{type} eq "noinfo") {
		printIndented($hxx, $level, sprintf("%s %s: public %s\n{", "class", $iname, $cld->{ancestor}));
	}
	elsif ($cld->{type} eq "struct") {
		if (defined $cld->{ancestor}) {
			printIndented($hxx, $level, sprintf("%s %s: public %s\n{", "struct", $iname, $cld->{ancestor}));
		}
		else {
			printIndented($hxx, $level, sprintf("%s %s\n{", "struct", $iname));
		}
	}
	else {
		die "$cxxname:$cld->{defline}: invalid implementation type specified for $cld->{class}";
	}

	if ($cld->{cont} ne "") {
		$hxx->print("\n");
		printIndented($hxx, $level, $cld->{cont});
	}

	for (my $found = 1; $found;) {
		$found = 0;
		foreach (@cl_list) {
			if ($_->{class} =~ m/^$cld->{class}::\w+$/) {
				$found = 1;
				$hxx->print("\n");
				printIndented($hxx, $level, "public:\n");
				printClass($_, $level+1);
				last
			}
		}
	}

	if (@{$cld->{methods}}) {
		my $last_allmod = "---";
		foreach my $met (@{$cld->{methods}}) {
			my $access;
			my $mods = "";
			foreach my $spec (@{$met->{specs}}) {
				$access = $spec, next if ($spec eq "public" || $spec eq "protected" || $spec eq "private");
				$mods .= "$spec ", next if ($spec eq "virtual" || $spec eq "static");
			}
			$access = 'public' unless (defined $access);
			while ($mods =~ s/\b(\w+)\b\s(.*\b\1\b)/$2/) {}
			my $allmod = "-$access-$mods-";
			if ($allmod ne $last_allmod) {
				$hxx->print("\n");
				printIndented($hxx, $level, "$access:\n");
				$last_allmod = $allmod;
			}
			elsif (defined $met->{comment}) {
				$hxx->print("\n");
			}
			if (defined $met->{comment}) {
				my $c = $met->{comment};
				if ($c ne "") {
					$c =~ s/^/\t/mg;
					printIndented($hxx, $level, sprintf("%s", $c));
				}
			}
			printIndented($hxx, $level, sprintf("\t%s;\n", formatMethodDecl("$mods$met->{ret}", "$met->{decl}")));
		}
	}

	if (@{$cld->{ats}}) {
		$hxx->print("\n");
		if (0) {
			if ($cld->{type} eq "struct") {
				printIndented($hxx, $level, "public:\n");
			}
			else {
				printIndented($hxx, $level, "protected:\n");
			}
		}
		my $last_access = "";
		foreach my $at (@{$cld->{ats}}) {
			die "internal error: content of $at doesn't start with [ +-]" unless ($at =~ m/^([-+ ])(.*)$/);
			my ($acc, $def) = ($1, $2);
			if ($acc ne $last_access) {
				printIndented($hxx, $level, sprintf("%s:\n", $acc eq "+" ? "public" : $acc eq " " ? "protected" : $acc eq "-" ? "private" : ""));
				$last_access = $acc;
			}
			printIndented($hxx, $level, sprintf("\t%s\n", $def));
		}
	}

	if (@{$cld->{friends}}) {
		printIndented($hxx, $level, "\npublic:\n");
		foreach my $friend (@{$cld->{friends}}) {
			printIndented($hxx, $level, sprintf("\t%s;\n", formatMethodDecl("friend", $friend)));
		}
	}

	printIndented($hxx, $level, sprintf("};\n"));
}

my $lineno = 0;
my $defline;
my $type = "object";
my $class;
my $class_last;
my $ancestor;
my @ifaces;
my $cont = "";
my @methods;
my @ats;
my @friends;

my $errors = 0;

my @funcspec;
my $func_comment;
my $func_ret;
my $func_decl;

MAIN: while (<$cxx>) {
	$lineno++;

	if (m,^/\*drt\s*$,) {
		if (defined $class) {
			push(@cl_list, {
					type		=> $type,
					defline		=> $defline,
					class		=> $class,
					ancestor	=> $ancestor,
					ifaces		=> [ @ifaces ],
					cont		=> $cont,
					ats		=> [ @ats ],
					methods		=> [ @methods ],
					friends		=> [ @friends ],
				});
			$type = "object";
			undef $class;
			undef $ancestor;
			@ifaces = ();
			$cont = "";
			@ats = ();
			@methods = ();
			@friends = ();
		}
		else {
			if (defined $ancestor || $cont ne "" || @ifaces || @ats || @methods || @friends) {
				STDERR->print("no class defined while some of the attributes are"), $errors++;
			}
		}
		while (<$cxx>) {
			$lineno++;
			if (m/^\s*\*\s*$/) {
				next;
			}
			elsif (m/^\s*\*\s*(\w+):\s*(.*?)\s*$/) {
				my ($key, $val) = ($1, $2);
				if ($key eq "include") {
					push(@includes, $val);
				}
				elsif ($key eq "ns") {
					$ns = $val;
				}
				elsif ($key eq "use") {
					push(@ns_use, $val);
				}
				elsif ($key eq "forward") {
					push(@forwards, $val);
				}
				elsif ($key eq "type") {
					$type = $val;
				}
				elsif ($key eq "class") {
					$class = $val;
					($class_last = $class) =~ s/.*:://;
					$defline = $lineno;
				}
				elsif ($key eq "ancestor") {
					$ancestor = $val;
				}
				elsif ($key eq "ifaces") {
					push(@ifaces, split(/s+/, $val));
				}
				elsif ($key eq "at") {
					push(@ats, " $val");
				}
				elsif ($key eq "ap") {
					push(@ats, "+$val");
				}
				elsif ($key eq "am") {
					push(@ats, "-$val");
				}
				elsif ($key eq "friend") {
					push(@friends, $val);
				}
				elsif ($key eq "co") {
					if ($val eq "{") {
						eval { $cont .= readContent($cxx, \$lineno, "}co") };
						die "$cxxname:$lineno: incorrect syntax for co" if ($@);
					}
					else {
						die "$cxxname:$lineno: incorrect syntax for co";
					}
				}
				else {
					STDERR->printf("$cxxname:$lineno: unknown statement\n");
					$errors++;
				}
			}
			elsif (m/^\s*\*\/\s*$/) {
				STDERR->printf("$cxxname:$lineno: fatal: ns undefined\n"), exit(1) unless (defined $ns);
				last;
			}
			else {
				STDERR->printf("$cxxname:$lineno: incorrect syntax\n"), $errors++;
			}
		}
	}
	elsif (m/^\s*$/) {
		@funcspec = ();
	}
	elsif (m/^{\s*$/) {
		if (defined $func_decl) {
			push(@methods, { specs => [ @funcspec ], ret => $func_ret, decl => $func_decl, comment => $func_comment });
			undef $func_decl;
		}
	}
	elsif (m/^\s/) {
		# skip
	}
	elsif (m/^DR_MET\((.*)\)\s*$/) {
		@funcspec = split(/\s+/, $1);
		undef $func_ret;
		undef $func_decl;
		undef $func_comment;
		STDERR->printf("$cxxname:$lineno: fatal: class undefined\n"), exit(1) unless (defined $class);
		FUNC_DECL: while (<$cxx>) {
			$lineno++;
			#STDERR->printf("class=%s\n", $class);
			#STDERR->printf("regex=%s\n", "^(.*)\\s*($class)::(\\w+)(\\(.*\\)):?\\s*\$");
			#STDERR->print("matching $_");
			if (m/^\/\*\*\s+$/) {
				$func_comment = $_;
				while (<$cxx>) {
					$lineno++;
					$func_comment .= $_;
					next FUNC_DECL if (m/^\s*\*\/\s*$/);
				}
				die "unable to find end of comment";
			}
			if (m/^${class}::(${class_last}\(.*\)(\s*const)?)\s*:?\s*$/) {
				$func_ret = "DR_CONSTRUCT";
				$func_decl = $1;
				last;
			}
			elsif (m/^${class}::(~${class_last}\(\))\s*$/) {
				$func_ret = "";
				$func_decl = $1;
				push(@funcspec, "virtual");
				last;
			}
			elsif (m/^(.*?)\s*($class)::(operator[^(]+)(\(.*\)(\s+const)?)\s*$/) {
				$func_ret = $1;
				$func_decl = "$3$4";
				last;
			}
			elsif (m/^(.*?)\s*($class)::(\w+)(\(.*\)(\s+const)?)\s*$/) {
				$func_ret = $1;
				$func_decl = "$3$4";
				last;
			}
			else {
				STDERR->printf("$cxxname:$lineno: expected method declaration\n");
				$errors++;
				next MAIN;
			}
		}
	}
	else {
		# nothing
	}
}

if (defined $class) {
	push(@cl_list, {
			type		=> $type,
			defline		=> $defline,
			class		=> $class,
			ancestor	=> $ancestor,
			ifaces		=> [ @ifaces ],
			cont		=> $cont,
			ats		=> [ @ats ],
			methods		=> [ @methods ],
			friends		=> [ @friends ],
		});
}
else {
	if (defined $ancestor || $cont ne "" || @ifaces || @ats || @methods || @friends) {
		STDERR->print("no class defined while some of the attributes are"), $errors++;
	}
}

STDERR->printf("$cxxname:$lineno: fatal: namespace undefined\n"), $errors++ unless (defined $ns);
exit(1) if ($errors);

$hxx->printf("/* The file is generated from %s, do not modify */\n", $cxxname);
$hxx->printf("/* The same license applies to use of header file */\n\n");
$hxx->printf("#ifndef %s\n# define %s\n\n", fileToHeader($ns, $hxxname), fileToHeader($ns, $hxxname));
foreach my $inc (@includes) {
	$hxx->printf("#include <$inc>\n");
}
$hxx->printf("\n%s\n", nsToMacroBegin($ns));
if (@ns_use) {
	$hxx->printf("\n");
	foreach my $use (@ns_use) {
		$hxx->printf("%s_USE;\n", nsToMacro($use));
	}
}
$hxx->printf("\n");
if (@forwards) {
	$hxx->printf("\n");
	foreach my $forward (@forwards) {
		$hxx->printf("%s\n", $forward);
	}
}
$hxx->printf("\n");

$def->printf("#include <dr/Const.hxx>\n\n");
$def->printf("%s\n\n", nsToMacroBegin($ns));

#STDERR->print(Dumper(\@cl_list));
while (@cl_list) {
	my $selected;
	foreach (@cl_list) {
		$selected = $_, last if ($_->{class} !~ m/::/);
	}
	die "$cxxname:$lineno: cannot find any base class in the list: ".Dumper(\@cl_list) unless (defined $selected);
	printClass($selected, 0);
}
$def->printf("\n\n%s\n", nsToMacroEnd($ns));
$hxx->printf("\n\n%s\n\n#endif\n", nsToMacroEnd($ns));


$hxx->flush();
$hxx->error()
	and die "failed to write hxx file: ".$hxx->error();
$def->flush();
$def->error()
	and die "failed to write hxx file: ".$def->error();

$file_trans->commit();
