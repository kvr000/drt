#!/usr/bin/perl

###
## drt library
##
## drt multiplatform development toolkit
##
## ----------------------------------------------------------------------------------
##
## Copyright (C) 2004-2008 Zbyněk Vyškovský
##
## ----------------------------------------------------------------------------------
##
## LICENSE:
##
## This file is part of drt
##
## drt is free software; you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation; either version 3 of the License, or (at your option)
## any later version.
##
## drt is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
## more details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with drt; if not, write to the Free Software Foundation, Inc., 51
## Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
##
## @copyright	2004-2008 Zbyněk Vyškovský
## @link	mailto:kvr@matfyz.cz
## @link	http://kvr.matfyz.cz/drt/
## @license	http://www.gnu.org/licenses/lgpl.txt GNU Lesser General Public License v3
###

use strict;
use warnings;

use FileHandle;
use Data::Dumper;
use Getopt::Std;

use File::Basename;
use lib dirname($0)."/perl";
use dr::FileTransaction;
use dr::XmiParser;
use dr::ModelStore;
use dr::Util;

sub fileToName($$)
{
	my $ns			= shift;
	my $file		= shift;

	$file =~ s/.*\///;
	$ns =~ s/::/\//g;
	return "${ns}/${file}";
}

sub fileToHeader($$)
{
	my $ns			= shift;
	my $file		= shift;

	$file =~ s/.*\///;
	$file =~ s/\./__/g;
	$ns =~ s/::/__/g;
	return "${ns}__${file}__";
}

sub nsToPub($)
{
	my $ns			= shift;
	$ns =~ s/::/_/g;
	$ns = uc($ns);
	return "${ns}_PUB";
}

sub nsToMacro($)
{
	my $ns			= shift;
	$ns =~ s/::/_/g;
	$ns = uc($ns);
	return "${ns}_NS";
}

sub nsToMacroBegin($)
{
	return nsToMacro(shift)."_BEGIN";
}

sub nsToMacroEnd($)
{
	return nsToMacro(shift)."_END";
}

sub readContent($$$)
{
	my $fd			= shift;
	my $lineno		= shift;
	my $fin			= shift;

	my $startline = $$lineno;

	my $cont = "";
	my $indent;

	my $line = <$fd>;
	if ($line =~ m/^(\s*\* ?)(\s+)/) {
		$indent = $2;
	}
	do {
		$$lineno++;
		if ($line =~ m/^\s*\*\*\//s) {
			die "didn't find close $fin block";
		}
		elsif ($line =~ m/^\s*\*\s?$fin\s*$/s) {
			return $cont;
		}
		elsif ($line =~ m/^(\s*\* ?)(.*)$/s) {
			my $l = $2;
			$l = substr($l, length($indent)) if ((defined $indent) && substr($l, 0, length($indent)) eq $indent);
			$cont .= $l;
		}
		else {
			die "unexpected content: $line";
		}
	} while (defined ($line = <$fd>));
	die "didn't find close $fin block starting at $startline";
}

sub readParagraph($$)
{
	my $fd			= shift;
	my $lineno		= shift;

	my $startline = $$lineno;

	my $cont = "";

	while (defined (my $line = <$fd>)) {
		$$lineno++;
		if ($line =~ m/^\s*\*\s+(\S.*)$/s) {
			$cont .= $1;
		}
		elsif ($line =~ m/^\s*\*\s*$/) {
			chomp $cont;
			return $cont;
		}
		else {
			die "unexpected content starting at $startline";
		}
	}
	die "didn't find empty line of paragraph starting at $startline";
}

sub tablength($)
{
	my $str			= shift;

	my $pos = 0;
	while ($str =~ m/^(.*?)\t(\t*)(.*)$/) {
		$pos += length($1)+8+length($2)*8;
		$pos -= $pos%8;
		$str = $3;
	}
	$pos += length($str);
	return $pos;
}

our %opts;
getopts('i', \%opts);

die "Usage: $0 [-i] cxx_file gen_file_base" unless (@ARGV == 2);
my $cxxname = shift(@ARGV);
die "passed file does not end with suffix .cxx" unless ($cxxname =~ m/(.*)\.cxx$/);
my $basename = shift(@ARGV);
my $hxxname = "$basename.hxx";

our $file_trans = dr::FileTransaction->new();

our @tag_defs;
our $tags;
our $hxx;
our $def;
our $str;
our $val;
our $sql;
our $all;
our $model_store = dr::ModelStore->new();

our $cxx = FileHandle->new($cxxname, "<")
	or die "failed to open $cxxname: $!";

our @cl_list;

our %gen = ();
our @includes = ();
our $ns;
our @ns_use = ();
our @forwards = ();

sub readModel($$$)
{
	my $name		= shift;
	my $ns			= shift;
	my $class		= shift;

	if ($name =~ m/^(.*)\/\.$/) {
		$name = $1;
		$ns =~ s/::/\//g;
		$class =~ s/::/\//g;
		$name .= "/$ns/$class";
	}

	my $model = $model_store->loadModel("$name");

	return $model;
}

sub expandClassNames($)
{
	my $cld			= shift;

	my @classes;
	for (my $c = $cld->{class}; defined $c; $c = ($c =~ m/^(\w+)::(.*)$/) ? $2 : undef) {
		push(@classes, $c);
	}
	return ( @classes );
}

sub escapeTagFind($)
{
	my $s			= shift;
	dr::Util::doDie("s undefined") unless (defined $s);
	$s =~ s/([\/])/\\$1/g;
	return $s;
}

sub addTagClass($$)
{
	my $cld			= shift;
	my $cxxname		= shift;
	foreach my $cname (expandClassNames($cld)) {
		push(@tag_defs, sprintf("%s\t%s\t/^%s\$/;\"\tc\tinherits:%s", $cname, $cxxname, escapeTagFind($cld->{line}), join(",", (defined $cld->{ancestor} ? $cld->{ancestor} : (), @{$cld->{ifaces}}))));
	}
}

sub addTagMethod($$$)
{
	my $cld			= shift;
	my $md			= shift;
	my $cxxname		= shift;
	foreach my $cname (expandClassNames($cld)) {
		push(@tag_defs, sprintf("%s\t%s\t/^%s\$/;\"\tf\tclass:%s\tsignature:%s", $md->{decl}, $cxxname, escapeTagFind($md->{line}), $cld->{class}, "()"));
	}
}

sub addTagAttribute($$$)
{
	my $cld			= shift;
	my $ad			= shift;
	my $cxxname		= shift;

	if ($ad->{def} =~ m/^([^\t]*)\t*(\w+);\s*$/) {
		my $name = $2;
		push(@tag_defs, sprintf("%s\t%s\t/^%s\$/;\"\tm\tclass:%s\taccess:%s", $name, $cxxname, escapeTagFind($ad->{line}), $cld->{class}, $ad->{access}));
		foreach my $cname (expandClassNames($cld)) {
			push(@tag_defs, sprintf("%s.%s\t%s\t/^%s\$/;\"\tm\tclass:%s\taccess:%s", $cname, $name, $cxxname, escapeTagFind($ad->{line}), $cld->{class}, $ad->{access}));
		}
	}
}

sub addTagConst($$$)
{
	my $cld			= shift;
	my $cnd			= shift;
	my $cxxname		= shift;

	push(@tag_defs, sprintf("%s\t%s\t/^%s\$/;\"\tm\tclass:%s\taccess:%s", $cnd->{name}, $cxxname, escapeTagFind($cnd->{line}), $cld->{class}, $cnd->{access}));
	foreach my $cname (expandClassNames($cld)) {
		push(@tag_defs, sprintf("%s.%s\t%s\t/^%s\$/;\"\tm\tclass:%s\taccess:%s", $cname, $cnd->{name}, $cxxname, escapeTagFind($cnd->{line}), $cld->{class}, $cnd->{access}));
	}
}

sub escapeCString($$)
{
	my $str			= shift;
	my $ind			= shift;

	my $ind_str = "\t"x$ind;

	$str =~ s/([\\"'])/\\$1/g;
	$str =~ s/\n/\\n"\n$ind_str"/g;
	return $str;
}

sub printDirect($$)
{
	my $fd			= shift;
	my $text		= shift;

	if ($fd) {
		$fd->print($text);
	}
}

sub mapUmlType($)
{
	my $type		= shift;

	return "Sint64" if ($type eq "long");
	return "Sint32" if ($type eq "int");
	return "Time::SysTime" if ($type eq "systime");

	die "unknown UML type $type";
}

sub addIndent($)
{
	my $s			= shift;

	$s =~ s/^/\t/gm;

	return $s;
}

sub printIndented($$$)
{
	my $fd			= shift;
	my $level		= shift;
	my $text		= shift;

	if ($fd) {
		if ($level > 0) {
			my $ind = "\t" x $level;
			$text =~ s/^(.)/$ind$1/gm;
		}
		$fd->print($text);
	}
}

sub formatMultiComment($)
{
	my $comment		= shift;

	my $out = "/**\n";
	foreach (@$comment) {
		$out .= " * $_\n";
	}
	$out .= " */\n";
}

sub formatShortComment($)
{
	my $comment		= shift;

	my $out = "/**< ";
	foreach (@$comment) {
		$out .= "$_ ";
	}
	$out .= "*/";
	return $out;
}

sub formatMethodDecl($$)
{
	my $ret			= shift;
	my $decl		= shift;

	my $full = $ret;
	if (tablength($full) < 32) {
		$full .= "\t"x((39-tablength($full))/8);
	}
	else {
		$full .= " ";
	}
	$full .= $decl;
	return $full;
}

sub formatMemberDecl($$)
{
	my $type		= shift;
	my $name		= shift;

	my $full = $type;
	if (tablength($full) < 32) {
		$full .= "\t"x((39-tablength($full))/8);
	}
	else {
		$full .= " ";
	}
	$full .= $name;
	return $full;
}

sub formatEnumLiteral($$$)
{
	my $name			= shift;
	my $value			= shift;
	my $comment			= shift;

	my $pre;
	if (@$comment > 1) {
		$pre = formatMultiComment($comment);
		$comment = [];
	}
	else {
		$pre = "";
	}
	my $full = $name;
	if (defined $value) {
		if (tablength($full) < 32) {
			$full .= "\t"x((39-tablength($full))/8);
		}
		else {
			$full .= " ";
		}
		$full .= " = $value";
	}
	$full .= ",";
	if (@$comment) {
		if (tablength($full) < 80) {
			$full .= "\t"x((87-tablength($full))/8);
		}
		else {
			$full .= " ";
		}
		$full .= formatShortComment($comment);
	}
	$full .= "\n";
	return $full;
}

sub printObjectHeader($$)
{
	my $cld			= shift;
	my $level		= shift;
	printIndented($hxx, $level, sprintf("%s %s %s: public %s%s\n{\n", "class", nsToPub($ns), $cld->{iname}, $cld->{ancestor}, join("", map({ ", $_" } @{$cld->{ifaces}}))));
	printIndented($hxx, $level, sprintf("\tDR_OBJECT_DECL_SIMPLE(%s, %s);\n", $cld->{iname}, $cld->{ancestor}));
	printDirect($def, "\n");
	printDirect($def, sprintf("DR_OBJECT_IMPL_IFACE%d(%s%s);\n", scalar @{$cld->{ifaces}}, $cld->{class}, join("", map({ ", $_" } @{$cld->{ifaces}}))));
	printDirect($def, sprintf("DR_OBJECT_DEF(%s_STR, %s, %s);\n", nsToMacro($ns), $cld->{class}, $cld->{ancestor}));
}

sub printClass($$);
sub printClass($$)
{
	my $cld			= shift;
	my $level		= shift;

	$cld->{iname} = $cld->{class};
	for (my $i = 0; $i < $level; $i++) {
		$cld->{iname} =~ s/^\w*:://;
	}

	for (my $i = 0; ; $i++) {
		splice(@cl_list, $i, 1), last if ($cl_list[$i] == $cld);
	}

	if ($cld->{type} eq "sqllayer") {
		$cld->{ancestor} = "dr::sql::SqlLayer" unless (defined $cld->{ancestor});
		die "$cxxname:$cld->{lineno}: sqllayer type used but no sql file opened" unless ($sql);
		unshift(@{$cld->{methods}}, { specs => [ "protected" ], ret => "DR_CONSTRUCT", "decl" => "$cld->{class}(dr::sql::SqlConnectionHold *db_connection)" });
		if ($cld->{typeflag}->{noreg}) {
			$sql->printf("DR_MET(protected)\n%s::%s(dr::sql::SqlConnectionHold *db_connection_):\n\t%s(db_connection_)\n{\n}\n\n", $cld->{class}, $cld->{class}, $cld->{ancestor});
		}
		else {
			push(@{$cld->{methods}}, { specs => [ "static", "public" ], ret => "$cld->{class} *", "decl" => "accCached(dr::sql::SqlConnectionHold *db_connection)" });
			$sql->printf("DR_MET(protected)\n%s::%s(dr::sql::SqlConnectionHold *db_connection_):\n\t%s(db_connection_)\n{\n\tdb_connection_->addDbLayer(this);\n}\n\n", $cld->{class}, $cld->{class}, $cld->{ancestor});
			$sql->printf("DR_MET(static public)\n%s *%s::accCached(dr::sql::SqlConnectionHold *holder)\n{\n\tif (%s *this_ = (%s *)holder->accDbLayer(comp_name))\n\t\treturn this_;\n\treturn tref(new %s(holder));\n}\n", $cld->{class}, $cld->{class}, $cld->{class}, $cld->{class}, $cld->{class});
		}
	}

	if ($cld->{type} eq "model") {
		die "$cxxname:$cld->{lineno}: no model loaded for class $cld->{class}" unless ($cld->{model});
		$cld->{type} = $cld->{model}->{type};
		$cld->{type} = "object" if ($cld->{type} eq "class");
		$cld->{type} = "object" if ($cld->{type} eq "association");
		$cld->{ancestor} = $cld->{model}->{ancestor} unless (defined $cld->{ancestor});
	}
	die "$cxxname:$cld->{lineno}: class $cld->{class} has no ancestor" if (!defined $cld->{ancestor} && !($cld->{type} eq "struct" || $cld->{type} eq "typedef" || $cld->{type} eq "enum"));

	if ($cld->{doc}) {
		my $doc = $cld->{doc};
		$doc =~ s/^/ \* /gm;
		$doc = "/**\n$doc */\n";
		printIndented($hxx, $level, $doc);
	}
	addTagClass($cld, $cxxname);
	my $has_inner = 1;
	if ($cld->{model} && @{$cld->{model}->{comment}}) {
		printIndented($hxx, $level, formatMultiComment($cld->{model}->{comment}));
	}
	if ($cld->{type} eq "object") {
		printObjectHeader($cld, $level);
	}
	elsif ($cld->{type} eq "sqllayer") {
		printObjectHeader($cld, $level);
	}
	elsif ($cld->{type} eq "noinfo") {
		printIndented($hxx, $level, sprintf("%s %s %s: public %s\n{", "class", nsToPub($ns), $cld->{iname}, $cld->{ancestor}));
	}
	elsif ($cld->{type} eq "struct") {
		if (defined $cld->{ancestor}) {
			printIndented($hxx, $level, sprintf("%s %s %s: public %s\n{", "struct", nsToPub($ns), $cld->{iname}, $cld->{ancestor}));
		}
		else {
			printIndented($hxx, $level, sprintf("%s %s %s\n{", "struct", nsToPub($ns), $cld->{iname}));
		}
	}
	elsif ($cld->{type} eq "typedef") {
		$has_inner = 0;
		die "$cxxname:$cld->{lineno}: typedef $cld->{class} has no base class" unless (defined $cld->{model} && defined $cld->{model}->{base});
		printIndented($hxx, $level, formatMethodDecl("typedef ".mapUmlType($cld->{model}->{base}), $cld->{iname}).";\n");
	}
	elsif ($cld->{type} eq "enum") {
		$has_inner = 0;
		printIndented($hxx, $level, "enum $cld->{iname}\n{\n");
		foreach my $literal (@{$cld->{model}->{literal_list}}) {
			printIndented($hxx, $level+1, formatEnumLiteral($literal->{name}, $literal->{value}, $literal->{comment}));
		}
		printIndented($hxx, $level, "};");
	}
	else {
		die "$cxxname:$cld->{lineno}: invalid implementation type $cld->{type} specified for $cld->{class}";
	}

	if ($cld->{cont} ne "") {
		printDirect($hxx, "\n");
		printIndented($hxx, $level, $cld->{cont});
	}

	for (my $found = 1; $found; ) {
		$found = 0;
		foreach (@cl_list) {
			if ($_->{class} =~ m/^$cld->{class}::\w+$/) {
				die "no sub class allowed for $cld->{class}: $_->{class}" unless ($has_inner);
				$found = 1;
				printDirect($hxx, "\n");
				printIndented($hxx, $level, "public:\n");
				printClass($_, $level+1);
				last;
			}
		}
	}

	if (@{$cld->{sqls}}) {
		die "$cxxname:$cld->{lineno}: found sql but no sql file was opened" unless ($sql);
		foreach my $sqd (@{$cld->{sqls}}) {
			push(@{$cld->{methods}}, { specs => [ "protected" ], ret => "void", "decl" => "prep_$sqd->{name}()" });
			push(@{$cld->{ats}}, { access => "protected", def => "Ref<dr::sql::SqlStatement>\tst_$sqd->{name};", line => $sqd->{line}, lineno => $sqd->{lineno} });
			$sql->printf("\nvoid %s::prep_%s()\n{\n\tst_%s.setNoref(db_connection->prepareStatement(\"%s\"));\n}\n", $cld->{class}, $sqd->{name}, $sqd->{name}, escapeCString($sqd->{query}, 2));
			addTagMethod($cld, { ret => "void", decl => "prep_$sqd->{name}", line => $sqd->{line}, lineno => $sqd->{lineno} }, $cxxname);
		}
	}

	if (@{$cld->{methods}}) {
		my $last_allmod = "---";
		foreach my $met (@{$cld->{methods}}) {
			my $access;
			my $mods = "";
			my $abstr = "";
			foreach my $spec (@{$met->{specs}}) {
				$access = $spec, next if ($spec eq "public" || $spec eq "protected" || $spec eq "private");
				$mods .= "$spec ", next if ($spec eq "virtual" || $spec eq "static");
				$abstr = " = 0", next if ($spec eq "abstract");
				die "$cxxname:$met->{lineno}: unknown method modifier $spec";
			}
			$access = 'public' unless (defined $access);
			while ($mods =~ s/\b(\w+)\b\s(.*\b\1\b)/$2/) {}
			my $allmod = "-$access-$mods-";
			if ($allmod ne $last_allmod) {
				printDirect($hxx, "\n");
				printIndented($hxx, $level, "$access:\n");
				$last_allmod = $allmod;
			}
			elsif (defined $met->{comment}) {
				printDirect($hxx, "\n");
			}
			if (defined $met->{comment}) {
				my $c = $met->{comment};
				if ($c ne "") {
					$c =~ s/^/\t/mg;
					printIndented($hxx, $level, sprintf("%s", $c));
				}
			}
			printIndented($hxx, $level, sprintf("\t%s;\n", formatMethodDecl("$mods$met->{ret}", "$met->{decl}$abstr")));
		}
	}

	if (@{$cld->{ats}}) {
		printDirect($hxx, "\n");
		my $last_access = "";
		foreach my $ad (@{$cld->{ats}}) {
			if ($ad->{access} ne $last_access) {
				$last_access = $ad->{access};
				printIndented($hxx, $level, sprintf("%s:\n", $last_access));
			}
			printIndented($hxx, $level, sprintf("\t%s\n", $ad->{def}));
			addTagAttribute($cld, $ad, $cxxname);
		}
	}
	if (@{$cld->{consts}}) {
		die "$cxxname:$cld->{lineno}: found consts but no val file was opened" unless ($val);
		printDirect($hxx, "\n");
		my $last_access = "";
		foreach my $cnd (@{$cld->{consts}}) {
			if ($cnd->{access} ne $last_access) {
				$last_access = $cnd->{access};
				printIndented($hxx, $level, sprintf("%s:\n", $last_access));
			}
			printIndented($hxx, $level, sprintf("\t%s;\n", formatMemberDecl("static const $cnd->{type}", $cnd->{name})));
			$val->printf("const %s %s::%s%s;\n", $cnd->{type}, $cld->{class}, $cnd->{name}, $cnd->{init});
			addTagConst($cld, $cnd, $cxxname);
		}
	}

	if (@{$cld->{friends}}) {
		printIndented($hxx, $level, "\npublic:\n");
		foreach my $friend (@{$cld->{friends}}) {
			printIndented($hxx, $level, sprintf("\t%s\n", formatMethodDecl("friend", $friend)));
		}
	}

	if ($has_inner) {
		printIndented($hxx, $level, sprintf("};\n"));
	}
}

sub parseConstDef($)
{
	my $def			= shift;

	die "incorrect syntax for const definition: $def" if ($def !~ m/^\s*(.*\S)\s+(\w+)(\(.+\))\s*$/);
	die "type undefined" if ($1 eq "");
	return ( type => $1, name => $2, init => $3 );
}

sub createModelCld($$)
{
	my $location		= shift;
	my $name		= shift;

	return {
		class			=> $name,
		type			=> "model",
		cont			=> "",
		typeflag		=> {},
		ifaces			=> [],
		methods			=> [],
		ats			=> [],
		consts			=> [],
		sqls			=> [],
		friends			=> [],
		model_loc		=> $location,
		model			=> readModel($location, $ns, $name),
	};
}

my $lineno = 0;
my $errors = 0;

my $cld;

my @consts;
my @strings;
my @wstrings;
my @bstrings;

MAIN: while (<$cxx>) {
	chomp;
	$lineno++;

	if (m/DR_CON\((\w+),\s*([^)]*)\)/) {
		my $l = $_;
		while ($l =~ m/DR_CON\((\w+),\s*([^)]*)\)(.*)$/) {
			push(@consts, { type => $1, val => $2 });
			$l = $3;
		}
	}
	if (m/DR_STR\(([^)]*)\)/) {
		my $l = $_;
		while ($l =~ m/DR_STR\(([^)]*)\)(.*)$/) {
			push(@strings, $1);
			$l = $2;
		}
	}
	if (m/DR_BSTR\(([^)]*)\)/) {
		my $l = $_;
		while ($l =~ m/DR_BSTR\(([^)]*)\)(.*)$/) {
			push(@bstrings, $1);
			$l = $2;
		}
	}
	if (m/DR_WSTR\(([^)]*)\)/) {
		my $l = $_;
		while ($l =~ m/DR_WSTR\(([^)]*)\)(.*)$/) {
			push(@wstrings, $1);
			$l = $2;
		}
	}
	if (m/^\/\*drt\s*$/) {
		if (defined $cld) {
			if ($cld->{class}) {
				$cld->{type} = "object" unless (defined $cld->{type});
				push(@cl_list, $cld);
			}
			else {
				if (defined $cld->{ancestor} || $cld->{cont} ne "" || @{$cld->{ifaces}} || @{$cld->{ats}} ||@{$cld->{consts}} || @{$cld->{methods}} || @{$cld->{friends}} || defined $cld->{doc}) {
					STDERR->print("no class defined while some of the attributes are"), $errors++;
				}
			}
		}
		$cld = {
			cont		=> "",
			typeflag	=> {},
			ifaces		=> [],
			methods		=> [],
			ats		=> [],
			consts		=> [],
			sqls		=> [],
			friends		=> [],
		};
		while (<$cxx>) {
			chomp;
			$lineno++;
			if (m/^\s*\*\s*$/) {
				next;
			}
			elsif (m/^\s*\*\s*(\w+):\s*(.*?)\s*$/) {
				my ($key, $val) = ($1, $2);
				if ($key eq "include") {
					push(@includes, $val);
				}
				elsif ($key eq "ns") {
					STDERR->printf("$cxxname:$lineno: fatal: ns already defined\n"), exit(1) if (defined $ns);
					$ns = $val;
				}
				elsif ($key eq "gen") {
					%gen = map({ ( $_ => 1 ) } split(/\s+/, $val));
				}
				elsif ($key eq "use") {
					push(@ns_use, $val);
				}
				elsif ($key eq "forward") {
					push(@forwards, $val);
				}
				elsif ($key eq "type") {
					if ($val =~ m/^(\w+)\((.*)\)$/) {
						$cld->{type} = $1;
						$cld->{typeflag} = { map({ ( $_ => 1 ) } split(",", $2)) };
					}
					else {
						$cld->{type} = $val;
					}
				}
				elsif ($key eq "class") {
					STDERR->print("$cxxname:$lineno: fatal: ns undefined\n"), exit(1) unless (defined $ns);
					$cld->{class} = $val;
					($cld->{class_last} = $cld->{class}) =~ s/.*:://;
					$cld->{lineno} = $lineno;
					$cld->{line} = $_;
				}
				elsif ($key eq "model") {
					STDERR->print("$cxxname:$lineno: fatal: ns undefined\n"), exit(1) unless (defined $ns);
					STDERR->print("$cxxname:$lineno: fatal: class undefined\n"), exit(1) unless (defined $cld->{class});
					STDERR->print("$cxxname:$lineno: only one model allowed\n") if (defined $cld->{model});
					$cld->{model_loc} = $val;
					$cld->{model} = eval {
						readModel($cld->{model_loc}, $ns, $cld->{class});
					}
						or STDERR->print("$cxxname:$lineno: failed to read model: $@\n"), $errors++;
				}
				elsif ($key eq "model_subs") {
					STDERR->print("$cxxname:$lineno: fatal: ns undefined\n"), exit(1) unless (defined $ns);
					STDERR->print("$cxxname:$lineno: fatal: class undefined\n"), exit(1) unless (defined $cld->{class});
					STDERR->print("$cxxname:$lineno: fatal: model location undefined\n") unless (defined $cld->{model_loc});
					foreach my $sub (split(/\s+/, $val)) {
						eval {
							my $scld = createModelCld($cld->{model_loc}, "$cld->{class}::$sub");
							$scld->{lineno} = $lineno;
							$scld->{line} = $_;
							push(@cl_list, $scld);
							1;
						}
							or STDERR->print("$cxxname:$lineno: failed to read model: $@\n"), $errors++;
					}
				}
				elsif ($key eq "ancestor") {
					$cld->{ancestor} = $val;
				}
				elsif ($key eq "ifaces") {
					push(@{$cld->{ifaces}}, split(/s+/, $val));
				}
				elsif ($key eq "at") {
					push(@{$cld->{ats}}, { access => "protected", def => $val, line => $_, lineno => $lineno });
				}
				elsif ($key eq "ap") {
					push(@{$cld->{ats}}, { access => "public", def => $val, line => $_, lineno => $lineno });
				}
				elsif ($key eq "am") {
					push(@{$cld->{ats}}, { access => "private", def => $val, line => $_, lineno => $lineno });
				}
				elsif ($key eq "cnp") {
					eval {
						push(@{$cld->{consts}}, { access => "public", parseConstDef($val), line => $_, lineno => $lineno });
					}
						or STDERR->print("$cxxname:$lineno: $@\n"), $errors++;
				}
				elsif ($key eq "sql") {
					my ( $name, $query );
					if ($val =~ m/^(\w+)\s*$/) {
						$name = $1;
						eval { $query = readParagraph($cxx, \$lineno); };
						die "$cxxname:$lineno: incorrect syntax for paragraph: $@" if ($@);
					}
					elsif ($val =~ m/^(\w+)\s+(\S.*)$/) {
						$name = $1;
						$query = $2;
					}
					if (!defined $name) {
						STDERR->print("$cxxname:$lineno: incorrect syntax for sql\n"), $errors++;
					}
					else {
						push(@{$cld->{sqls}}, { line => $_, lineno => $lineno, name => $name, query => $query });
					}
				}
				elsif ($key eq "friend") {
					push(@{$cld->{friends}}, $val);
				}
				elsif ($key eq "co") {
					if ($val =~ m/^(\w*)\s*{$/) {
						eval { $cld->{cont} .= ($1 ? "$1:\n" : "").addIndent(readContent($cxx, \$lineno, "}co")) };
						die "$cxxname:$lineno: incorrect syntax for co: $@" if ($@);
					}
					else {
						die "$cxxname:$lineno: incorrect syntax for co: need co:{";
					}
				}
				elsif ($key eq "doc") {
					if ($val eq "{") {
						eval { $cld->{doc} .= readContent($cxx, \$lineno, "}doc") };
						die "$cxxname:$lineno: incorrect syntax for doc: $@" if ($@);
					}
					else {
						die "$cxxname:$lineno: incorrect syntax for doc: need doc:{";
					}
				}
				else {
					STDERR->printf("$cxxname:$lineno: unknown statement\n");
					$errors++;
				}
			}
			elsif (m/^\s*\*\/\s*$/) {
				last;
			}
			else {
				STDERR->printf("$cxxname:$lineno: incorrect syntax\n"), $errors++;
			}
		}
	}
	elsif (m/^\s*$/) {
		#@funcspec = ();
	}
	elsif (m/^\s/) {
		# skip
	}
	elsif (m/^DR_MET\((.*)\)\s*$/) {
		my $metd = {
			specs		=> [ split(/\s+/, $1) ],
		};
		my $abstr = grep({ $_ eq "abstract" } @{$metd->{specs}});
		STDERR->printf("$cxxname:$lineno: fatal: class undefined\n"), exit(1) unless (defined $cld && defined $cld->{class});
		FUNC_DECL: while (<$cxx>) {
			chomp;
			$lineno++;
			if (m/^\/\*\*\s*$/) {
				$metd->{comment} = "$_\n";
				while (<$cxx>) {
					chomp;
					$lineno++;
					$metd->{comment} .= "$_\n";
					next FUNC_DECL if (m/^\s*\*\/\s*$/);
				}
				die "unable to find end of comment";
			}
			if ($abstr) {
				if (m/^\/\/\s?(.*)$/s) {
					$_ = $1;
				}
				else {
					STDERR->printf("$cxxname:$lineno: abstract declaration must start with //\n");
					$errors++;
				}
			}
			if (m/^$cld->{class}::($cld->{class_last}\(.*\)(\s*const)?)\s*:?\s*$/) {
				$metd->{ret} = "DR_CONSTRUCT";
				$metd->{decl} = $1;
				last;
			}
			elsif (m/^$cld->{class}::(~$cld->{class_last}\(\))\s*$/) {
				$metd->{ret} = "";
				$metd->{decl} = $1;
				push(@{$metd->{spec}}, "virtual");
				last;
			}
			elsif (m/^(.*?)\s*($cld->{class})::(operator[^(]+)(\(.*\)(\s+const)?)\s*$/) {
				$metd->{ret} = $1;
				$metd->{decl} = "$3$4";
				last;
			}
			elsif (m/^(.*?)\s*($cld->{class})::(\w+)(\(.*\)(\s+const)?)\s*$/) {
				$metd->{ret} = $1;
				$metd->{decl} = "$3$4";
				last;
			}
			else {
				STDERR->printf("$cxxname:$lineno: expected method declaration\n");
				$errors++;
				next MAIN;
			}
		}
		push(@{$cld->{methods}}, $metd);
	}
	else {
		# nothing
	}
}

if (!defined $cld) {
	# ignore
}
elsif (defined $cld->{class}) {
	$cld->{type} = "object" unless (defined $cld->{type});
	push(@cl_list, $cld);
}
else {
	if (defined $cld->{ancestor} || $cld->{cont} ne "" || @{$cld->{ifaces}} || @{$cld->{ats}} || @{$cld->{consts}} || @{$cld->{methods}} || @{$cld->{friends}} || defined $cld->{doc}) {
		STDERR->print("no class defined while some of the attributes are"), $errors++;
	}
}

if (!%gen) {
	%gen = map({ ( $_ => 1 ) } ( "def", "hxx", "all" ));
	$gen{str} = 1 if (@strings || @bstrings || @wstrings);
	$gen{val} = 1 if (grep({ @{$_->{consts}} } @cl_list));
	$gen{sql} = 1 if (grep({ @{$_->{sqls}} || $_->{type} eq "sqllayer" } @cl_list));
}

if ($gen{hxx} || $gen{def}) {
	STDERR->printf("$cxxname:$lineno: fatal: namespace undefined\n"), $errors++ unless (defined $ns);
}
exit(1) if ($errors);

if ($gen{hxx} && !$opts{i}) {
	$hxx = $file_trans->createTruncated("$basename.hxx");
}
if ($gen{def}) {
	$def = $file_trans->createTruncated("$basename-def.hxx");
}
if ($gen{str}) {
	$str = $file_trans->createTruncated("$basename-str.hxx");
}
if ($gen{val}) {
	$val = $file_trans->createTruncated("$basename-val.hxx");
}
if ($gen{sql}) {
	$sql = $file_trans->createTruncated("$basename-sql.hxx");
}
if (!$gen{noall}) {
	$all = $file_trans->createTruncated("$basename-all.hxx");
}
if (!$gen{notags}) {
	$tags = $file_trans->createTruncated("$basename.tags");
}

if ($all) {
	my $name = $basename;
	$name =~ s/.*\///;
	$all->printf("/* The file is generated from %s, do not modify */\n", $cxxname);
	if ($hxx) {
		$all->printf("#include <%s>\n", fileToName($ns, $hxxname));
	}
	foreach (keys %gen) {
		next if ($_ eq "all" || $_ eq "hxx");
		$all->printf("#include \"_gen/%s-%s.hxx\"\n", $name, $_);
	}
}

if ($str) {
	$str->printf("/* The file is generated from %s, do not modify */\n", $cxxname);
	$str->printf("#include <dr/Const.hxx>\n\n");
	my %printed;
	foreach (@consts) {
		next if ($printed{$_});
		$printed{$_} = 1;
		$str->printf("static const $_->{type} drc$_->{type}_$_->{val}($_->{val});\n", $_, $_);
	}
	foreach (@strings) {
		next if ($printed{$_});
		$printed{$_} = 1;
		$str->printf("static const dr::String drcstr_%s(dr::Const::string(\"%s\"));\n", $_, $_);
	}
	my %bprinted;
	foreach (@bstrings) {
		next if ($bprinted{$_});
		$bprinted{$_} = 1;
		$str->printf("static const dr::BString drcbstr_%s(dr::Const::bstring(\"%s\"));\n", $_, $_);
	}
	my %wprinted;
	foreach (@wstrings) {
		next if ($wprinted{$_});
		$wprinted{$_} = 1;
		$str->printf("static const dr::WString drcwstr_%s(dr::Const::wstring(\"%s\"));\n", $_, $_);
	}
}

if ($val) {
	$val->printf("/* The file is generated from %s, do not modify */\n", $cxxname);
	$val->printf("#include <dr/Const.hxx>\n\n");
	$val->printf("%s\n\n", nsToMacroBegin($ns));
}

if ($sql) {
	$sql->printf("/* The file is generated from %s, do not modify */\n", $cxxname);
	$sql->printf("%s\n\n", nsToMacroBegin($ns));
}

if ($hxx) {
	$hxx->printf("/* The file is generated from %s, do not modify */\n", $cxxname);
	$hxx->printf("/* The same license applies to use of header file */\n\n");
	$hxx->printf("#ifndef %s\n# define %s\n\n", fileToHeader($ns, $hxxname), fileToHeader($ns, $hxxname));
	foreach my $inc (@includes) {
		$hxx->printf("#include <$inc>\n");
	}
	$hxx->printf("\n%s\n", nsToMacroBegin($ns));
	if (@ns_use) {
		$hxx->printf("\n");
		foreach my $use (@ns_use) {
			$hxx->printf("%s_USE;\n", nsToMacro($use));
		}
	}
	$hxx->printf("\n");
	if (@forwards) {
		$hxx->printf("\n");
		foreach my $forward (@forwards) {
			$hxx->printf("%s\n", $forward);
		}
	}
	$hxx->printf("\n");
}

if ($def) {
	$def->printf("#include <dr/Const.hxx>\n\n");
	$def->printf("%s\n\n", nsToMacroBegin($ns));
}

if (@cl_list) {
	die "class list specified but header not open" unless ($gen{hxx});
	while (@cl_list) {
		my $selected;
		foreach (@cl_list) {
			$selected = $_, last if ($_->{class} !~ m/::/);
		}
		die "$cxxname:$lineno: cannot find any base class in the list: ".Dumper(\@cl_list) unless (defined $selected);
		printClass($selected, 0);
	}
}
if ($sql) {
	$sql->printf("\n\n%s\n", nsToMacroEnd($ns));
}
if ($val) {
	$val->printf("\n\n%s\n", nsToMacroEnd($ns));
}
if ($def) {
	$def->printf("\n\n%s\n", nsToMacroEnd($ns));
}
if ($hxx) {
	$hxx->printf("\n\n%s\n\n#endif\n", nsToMacroEnd($ns));
}
if ($tags) {
	foreach my $tagline (sort({ $a cmp $b } @tag_defs)) {
		$tags->printf("%s\n", $tagline);
	}
}

if ($file_trans->commit()) {
	my $dummy = FileHandle->new("$basename.gen", ">");
	$dummy->printf("ok\n");
	if (!$dummy->close()) {
		die "failed to update dummy file $basename.gen: $!";
	}
}
