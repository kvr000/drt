#!/usr/bin/perl

##
## drt library
##
## drt multiplatform development toolkit
##
## ----------------------------------------------------------------------------------
##
## Copyright (C) 2004-2008 Zbyněk Vyškovský
##
## ----------------------------------------------------------------------------------
##
## LICENSE:
##
## This file is part of drt
##
## drt is free software; you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation; either version 3 of the License, or (at your option)
## any later version.
##
## drt is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
## more details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with drt; if not, write to the Free Software Foundation, Inc., 51
## Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
##
## @author	2004-2008 Zbyněk Vyškovský
## @link	mailto:kvr@matfyz.cz
## @link	http://kvr.matfyz.cz/drt/
## @license	http://www.gnu.org/licenses/lgpl.txt GNU Lesser General Public License v3
##

# run the program with DRO_MM=pb and analyse its output with this program

use strict;
use warnings;

my %mem;

my $order = 0;

my $pending;
my $seq = 0;

for (;;) {
	if (!defined $pending) {
		last unless (defined ($pending = <>));
	}
	if ($pending =~ m/^(allocated|freeing) block 0x([\da-f]+) \((\d+)\)$/) {
		my ( $op, $block, $length, $thread, $backtrace ) = ( $1, $2, $3, undef, undef );
		if (defined ($pending = <>) && $pending =~ m/^\x00?--- Thread (\w+|\(nil\)) backtrace:$/) {
			$thread = $1;
			$backtrace = $pending;
			while (defined ($pending = <>)) {
				$backtrace .= $pending;
				undef $pending, last if ($pending =~ m/^\x00?--- Thread (\w+|\(nil\)) end$/);
			}
		}
		if ($op eq "allocated") {
			$seq++;
			my $md = $mem{$block};
			if ($md) {
				print("memory $block ($length) allocated for second time:\n$md->{backtrace}\n");
			}
			$mem{$block} = {
				block		=> $block,
				length		=> $length,
				thread		=> $thread,
				backtrace	=> $backtrace,
				order		=> $order++,
				seq		=> $seq,
			};
		}
		else {
			my $md = $mem{$block};
			if (!$md) {
				print("memory $block ($length) freed but not allocated:\n$backtrace\n");
			}
			else {
				delete $mem{$block};
			}
		}
	}
	else {
		undef $pending;
	}
}

foreach my $md (sort({ $a->{order} <=> $b->{order} } values %mem)) {
	next if ($md->{backtrace} =~ m/[(<]_ZN2dr5Const/);
	next if ($md->{backtrace} =~ m/[(<]_ZN2dr6Static6create/);
	next if ($md->{backtrace} =~ m/[(<]_ZN2dr11Thread_impl18postinitMainThread/);
	next if ($md->{backtrace} =~ m/[(<]_ZN2dr5Lockp6s_initEv/);
	next if ($md->{backtrace} =~ m/[(<]_ZN2dr9Subsystem12getSubsystem/);
	next if ($md->{backtrace} =~ m/[(<]_ZN2dr6Thread19createMessageSerial/);
	next if ($md->{backtrace} =~ m/[(<]_ZN2dr23createMemExceptInstanceEv/);
	next if ($md->{backtrace} =~ m/\(_ZN2dr3net9RpcHelper12StructMapperC1EPKNS_6StringElPFvPNS0_10RpcDecoderEPvES5_z/);
	print("memory $md->{block} ($md->{length}) seq=$md->{seq} not freed:\n$md->{backtrace}\n");
}
