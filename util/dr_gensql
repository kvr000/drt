#!/usr/bin/perl

###
## drt library
##
## drt multiplatform development toolkit
##
## ----------------------------------------------------------------------------------
##
## Copyright (C) 2004-2008 Zbyněk Vyškovský
##
## ----------------------------------------------------------------------------------
##
## LICENSE:
##
## This file is part of drt
##
## drt is free software; you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation; either version 3 of the License, or (at your option)
## any later version.
##
## drt is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
## more details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with drt; if not, write to the Free Software Foundation, Inc., 51
## Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
##
## @copyright	2004-2008 Zbyněk Vyškovský
## @link	mailto:kvr@matfyz.cz
## @link	http://kvr.matfyz.cz/drt/
## @license	http://www.gnu.org/licenses/lgpl.txt GNU Lesser General Public License v3
###

use strict;
use warnings;

use FileHandle;
use Data::Dumper;
use Getopt::Std;
use File::Basename;

use lib dirname($0)."/perl";
use dr::FileTransaction;
use dr::SepOutput;
use dr::ModelStore;
use dr::GenmapReader;
use dr::Util qw(defvalue tabalign);


sub fixModelInfo($)
{
	my $model		= shift;

	if (defined $model->{db_table}) {
		# ok
	}
	elsif (defined (my $db_table = $model->checkDrTagValue("db_table"))) {
		$model->{db_table} = $db_table;
	}
	else {
		($model->{db_table} = $model->{name}); # =~ s/([[:lower:]])([[:upper:]])/$1_$2/g;
		#$model->{db_table} = lc($model->{db_table});
	}
}

our %opts;
getopts('', \%opts);

die "Usage: $0 [-i] list_file target_file" unless (@ARGV >= 2);
my $listname = shift(@ARGV);
my $targname = shift(@ARGV);
die "passed file does not end with suffix .list" unless ($listname =~ m/(.*)\.(db|list)$/);

our $file_trans = dr::FileTransaction->new();

our $model_store = dr::ModelStore->new();
$model_store->registerFixier(\&fixModelInfo);


sub readModel($$)
{
	my $location		= shift;
	my $name		= shift;

	my $model = $model_store->loadModel($location, $name);

	fixModelInfo($model);

	return $model;
}

our %SQL_UML_TYPES_PRIM = (
	Boolean			=> "bool",
	Integer			=> "int",
	Long			=> "bigint",
	long			=> "bigint",
	int			=> "int",
	float			=> "float",
	Integer			=> "int",
	date			=> "date",
	datetime		=> "datetime",
	timestamp		=> "timestamp",
);

our %SQL_UML_TYPES_VAR = (
	string			=> "varchar",
	binary			=> "varbinary",
);

sub dieAttrContext($$)
{
	my $field		= shift;
	my $msg			= shift;

	dr::Util::doDie("$field->{owner}->{filename}:0: $field->{owner}->{full}.$field->{name}: $msg");
}

sub translateSqlType($)
{
	my $field		= shift;

	eval {
		my ( $type, $tagger ) = $field->getFinalTypeWithTagger();

		if (defined (my $db_type = defvalue($tagger->checkTagValue("db_type"), $tagger->checkTagValue("db_conversion")))) {
			if (($db_type eq "enum" || $db_type eq "set") && $type->{stype} eq "enum") {
				return "int";
				return "$db_type(".join(", ", map({
							$_->getDrTagger()->getTag("db_value")->{value}
						} @{$type->{literal_list}})).")";
			}
			else {
				if ($db_type =~ m/^(\w+)\((\d+)\)$/) {
					if (my $sqlt = $SQL_UML_TYPES_VAR{$1}) {
						return "$sqlt($2)";
					}
					die "cannot map $db_type";
				}
				else {
					if (my $sqlt = $SQL_UML_TYPES_PRIM{$db_type}) {
						return $sqlt;
					}
					die "cannot map $db_type";
				}
			}
		}
		else {
			if ($type->{stype} eq "primitive") {
				my $ptype = $type->{type};
				if ($ptype =~ m/^(\w+)\((\d+)\)$/) {
					if (my $sqlt = $SQL_UML_TYPES_VAR{$1}) {
						return "$sqlt($2)";
					}
					die "cannot map $ptype";
				}
				else {
					if (my $sqlt = $SQL_UML_TYPES_PRIM{$ptype}) {
						return $sqlt;
					}
					die "cannot map $ptype";
				}
			}
			elsif ($type->{stype} eq "enum") {
				return "int";
			}
			else {
				die "unknown stype $type->{stype} for class $type->{full}";
			}
		}
	}
		or dieAttrContext($field, $@);
}

sub translateSqlTypeDecl($$)
{
	my $main		= shift;
	my $field		= shift;

	my $has_default = 0;

	my $sql_type = translateSqlType($field);
	if (defined (my $doMandatory = $main->checkDrTagValue("doMandatory"))) {
		$sql_type .= " NOT NULL default $doMandatory";
		$has_default = 1;
	}
	elsif ($main->{mandatory} eq 0) {
		$sql_type .= " NULL";
	}
	elsif ($main->{mandatory} eq 1) {
		$sql_type .= " NOT NULL";
	}
	else {
		dieAttrContext($main, "unexpected mandatory: $main->{mandatory}");
	}
	if ($main->checkDrTagValue("serial")) {
		$sql_type .= " AUTO_INCREMENT";
	}
	if (!$has_default) {
		if (defined (my $db_default = $main->checkDrTagValue("db_default")) && 0) {
			$sql_type .= " default $db_default";
		}
		elsif (defined (my $default = $main->{default})) {
			$sql_type .= " default $default";
		}
	}
	return $sql_type;
}

my $lineno = 0;

my @models = ();

my $errors = 0;

my $list = dr::GenmapReader::open($listname, "sql", @ARGV ? \@ARGV : undef);
while (my ($section, $classname) = $list->getNext()) {
	eval {
		push(@models, readModel($section, $classname));
		1;
	}
		or $errors++, STDERR->print($@ =~ m/^\S+:\d+:/ ? $@ : $list->getContext().": $@");
}

my $sql = $file_trans->createTruncated($targname);
foreach my $model (@models) {
	my @primary;
	$sql->print("create table $model->{db_table} (\n");
	my $sqlin = dr::SepOutput->new($sql, { sep_in => ",", sep_all => "\n" });
	foreach my $field (@{$model->{field_list}}) {
		eval {
			if ($field->{stype} eq "field") {
				$sqlin->printObj("\t".defvalue($field->checkDrTagValue("db_name"), $field->{name}));
				$sqlin->printAligned(translateSqlTypeDecl($field, $field), 40);
				if ($field->getRole()->{primary}) {
					push(@primary, $field->{name});
				}
			}
			elsif ($field->{stype} eq "assoc" || $field->{stype} eq "compos") {
				my @assoc = $field->expandAssocAttrs();
				foreach my $assoc_field (@assoc) {
					push(@primary, $assoc_field->{name}) if ($field->getRole()->{primary});
					$sqlin->printObj("\t$assoc_field->{name}");
					$sqlin->printAligned(translateSqlTypeDecl($field, $assoc_field->{field}), 40);
					$sqlin->printAlignedAdd("-- $assoc_field->{field}->{owner}->{full}.$assoc_field->{field}->{name}", 72);
				}
			}
			elsif ($field->{stype} eq "child") {
				# ignore childs for db at all
			}
			else {
				dr::Util::doDie("$field->{owner}->{filename}:0: invalid stype $field->{stype}");
			}
			1;
		}
			or $errors++, STDERR->print($@);
	}
	if (@primary) {
		$sqlin->printFlushing("\tprimary key (");
		my $sqlprim = dr::SepOutput->new($sql, { sep_in => ", ", sep_all => "" });
		foreach (@primary) {
			$sqlprim->printObj($_);
		}
		undef $sqlprim;
		$sqlin->print(")");
	}
	foreach my $index ($model->getIndexes()) {
		my $type = $index->{type} eq "nonunique" ? "" : "$index->{type} ";
		$sqlin->printFlushing("\t${type}index $index->{name} (");
		my $sqlind = dr::SepOutput->new($sql, { sep_in => ", ", sep_all => "" });
		$sqlind->printObj($_) foreach (@{$index->{fields}});
		undef $sqlind;
		$sqlin->print(")");
	}
	undef $sqlin;
	$sql->print(") default charset=utf8;\n\n");
}

die "Unrecoverable errors occurred" if ($errors);

if ($file_trans->commit()) {
}
