#!/usr/bin/perl

###
## drt library
##
## drt multiplatform development toolkit
##
## ----------------------------------------------------------------------------------
##
## Copyright (C) 2004-2008 Zbyněk Vyškovský
##
## ----------------------------------------------------------------------------------
##
## LICENSE:
##
## This file is part of drt
##
## drt is free software; you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation; either version 3 of the License, or (at your option)
## any later version.
##
## drt is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
## more details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with drt; if not, write to the Free Software Foundation, Inc., 51
## Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
##
## @copyright	2004-2008 Zbyněk Vyškovský
## @link	mailto:kvr@matfyz.cz
## @link	http://kvr.matfyz.cz/drt/
## @license	http://www.gnu.org/licenses/lgpl.txt GNU Lesser General Public License v3
###

use strict;
use warnings;

use FileHandle;
use Data::Dumper;
use Getopt::Std;

use File::Basename;
use File::Find;
use lib dirname($0)."/perl";
use dr::FileTransaction;
use dr::FileParser;
use dr::ModelStore;
use dr::TagWriter;
use dr::Util qw(tabalign escapeString escapeStringContent);
use dr::prog::java::JavaGenerator;
use dr::prog::gen::CopyGenerator;


our %opts;
our $file_trans;


sub fileToName($$)
{
	my $ns			= shift;
	my $file		= shift;

	$file =~ s/.*\///;
	$ns =~ s/::/\//g;
	return "${ns}/${file}";
}

sub fileToHeader($$)
{
	my $ns			= shift;
	my $file		= shift;

	$file =~ s/.*\///;
	$file =~ s/\./__/g;
	$ns =~ s/::/__/g;
	return "${ns}__${file}__";
}

sub nsToPub($)
{
	my $ns			= shift;
	$ns =~ s/::/_/g;
	$ns = uc($ns);
	return "${ns}_PUB";
}

sub nsToMacro($)
{
	my $ns			= shift;
	$ns =~ s/::/_/g;
	$ns = uc($ns);
	return "${ns}_NS";
}

sub nsToMacroBegin($)
{
	return nsToMacro(shift)."_BEGIN";
}

sub nsToMacroEnd($)
{
	return nsToMacro(shift)."_END";
}

sub readContent($$)
{
	my $fd			= shift;
	my $fin			= shift;

	my $startline = $fd->getContext();

	my $cont = "";
	my $indent;

	my $line = $fd->readLine();
	if ($line =~ m/^(\s*\* ?)(\s+)/) {
		$indent = $2;
	}
	do {
		if ($line =~ m/^\s*\*\*\//s) {
			die "didn't find close $fin block";
		}
		elsif ($line =~ m/^\s*\*\s?$fin\s*$/s) {
			return $cont;
		}
		elsif ($line =~ m/^(\s*\* ?)(.*)$/s) {
			my $l = $2;
			$l = substr($l, length($indent)) if ((defined $indent) && substr($l, 0, length($indent)) eq $indent);
			$cont .= $l;
		}
		else {
			die "unexpected content: $line";
		}
	} while (defined ($line = $fd->readLine()));
	die "didn't find close $fin block starting at $startline";
}

sub readParagraph($)
{
	my $fd			= shift;

	my $startline = $fd->getContext();

	my $cont = "";

	while (defined (my $line = $fd->readLine())) {
		if ($line =~ m/^\s*\*\s+(\S.*)$/s) {
			$cont .= $1;
		}
		elsif ($line =~ m/^\s*\*\s*$/) {
			chomp $cont;
			return $cont;
		}
		else {
			die "unexpected content starting at $startline";
		}
	}
	die "didn't find empty line of paragraph starting at $startline";
}

sub convertToJavaClass
{
	my $classname			= shift;

	$classname =~ s/::/./g;

	return $classname;
}

sub escapeJavaTypeValue
{
	my $java_type			= shift;
	my $value			= shift;

	return "${value}L" if ($java_type eq "Long");
	return escapeStringContent($value) if ($java_type eq "String");
	return $value ? "true" : "false" if ($java_type eq "Boolean");
	return $value;
}

sub generateEntityBean($$$$)
{
	my $context			= shift;
	my $location			= shift;
	my $classname			= shift;
	my $more			= shift;

	my $jclassname = $classname; $jclassname =~ s/::/./g;
	my $filename = $jclassname; $filename =~ s/\./\//g;
	my $pkgname = $jclassname; $pkgname =~ s/\.\w+$//;
	my $classonly = $jclassname; $classonly =~ s/^.*\.//g;

	return if ($context->{processed}->{$filename});

	my $model = $context->{model_store}->loadModel($location, $classname);

	my $fdbean = $context->{file_trans}->updateChanged($context->{dst_dir}."/$filename.java");
	$context->{processed}->{$filename} = 1;

	$fdbean->print("package $pkgname;\n\n");
	my $sysimport_ctx = $fdbean->rememberContext();
	$sysimport_ctx->printOnce("import javax.persistence.Entity;\n");
	$sysimport_ctx->printOnce("import javax.persistence.Table;\n");
	my $import_ctx = $fdbean->rememberContext();

	$fdbean->print("\n\n\@Entity\n\@Table(name=\"$classonly\")\npublic class $classonly\n{\n");
	$fdbean->indent(1);
	my $pk_ctx = $fdbean->rememberContext();
	my $pk_attr_ctx = $pk_ctx->subContext()->indentContext(1);
	my $pk_method_ctx = $pk_ctx->subContext()->indentContext(1);
	my $pk_end_ctx = $fdbean->rememberContext();
	$fdbean->printIndented("\n");
	my $attr_ctx = $fdbean->rememberContext();
	$fdbean->printIndented("\n");
	my $method_ctx = $fdbean->rememberContext();

	my @primary;
	my @primary_types;

	foreach my $attr (@{$model->getAttrs()}) {
		my $is_primary = $attr->getRole()->{primary};
		push(@primary, $attr) if ($is_primary);
		if ($attr->{stype} eq "attr") {
			my $java_type = dr::prog::java::JavaGenerator::mapJavaAttrType($attr);
			my $method = ucfirst($attr->{name});
			$sysimport_ctx->printOnce("import javax.persistence.Column;\n");
			my $tmap = "";
			$tmap .= "\@Column(name=\"".$attr->{name}."\")\n";
			if ($attr->checkDrTagValue("serial")) {
				$sysimport_ctx->printOnce("import javax.persistence.GenerationType;\n");
				$sysimport_ctx->printOnce("import javax.persistence.GeneratedValue;\n");
				$tmap .= "\@GeneratedValue(strategy=GenerationType.AUTO)\n";
			}
			my $dfl = (defined $attr->{default}) ?
				" = ".escapeJavaTypeValue($java_type, $attr->{default}) :
				(defined $attr->checkDrTagValue("do_mandatory")) ? " = ".escapeJavaTypeValue($java_type, $attr->checkDrTagValue("do_mandatory")) :
				"";
			my $athis = $is_primary ? "this.pk" : "this";
			($is_primary ? $pk_attr_ctx : $attr_ctx)->print($tmap.tabalign("protected $java_type", 32)."$attr->{name}$dfl;\n");
			$method_ctx->print(tabalign("public void", 32)."set$method($java_type $attr->{name}_)\n{\n\t$athis.$attr->{name} = $attr->{name}_;\n}\n\n");
			$method_ctx->print(tabalign("public $java_type", 32)."get$method()\n{\n\treturn $athis.$attr->{name};\n}\n\n");
			if ($is_primary) {
				$pk_method_ctx->print(tabalign("public void", 32)."set$method($java_type $attr->{name}_)\n{\n\tthis.$attr->{name} = $attr->{name}_;\n}\n\n");
				$pk_method_ctx->print(tabalign("public $java_type", 32)."get$method()\n{\n\treturn this.$attr->{name};\n}\n\n");
			}
		}
		elsif ($attr->{stype} eq "child") {
			if ($attr->checkDrTagValue("tied")) {
				my $tied_class = $attr->getAssocTarget();
				$import_ctx->printOnce("import ".convertToJavaClass($tied_class->{full}).";\n");
				$sysimport_ctx->printOnce("import javax.persistence.OneToMany;\n");
				$sysimport_ctx->printOnce("import javax.persistence.JoinColumn;\n");
				$sysimport_ctx->printOnce("import javax.persistence.FetchType;\n");
				$sysimport_ctx->printOnce("import javax.persistence.CascadeType;\n");
				$sysimport_ctx->printOnce("import java.util.Set;\n");
				my $tmap = "";
				$tmap .= "\@OneToMany(fetch=FetchType.EAGER, cascade=CascadeType.ALL)\n";
				$tmap .= "\@JoinColumn(name=\"".
				join(",", map({ $_->{name} } $tied_class->getCompos()->expandAssocAttrs())).
				"\")\n";
				$attr_ctx->print($tmap.tabalign("private Set<$tied_class->{name}>", 32)."$attr->{name};\n\n");
				$method_ctx->print(tabalign("public Set<$tied_class->{name}>", 32)."get".ucfirst($attr->{name})."()\n{\n\treturn $attr->{name};\n}\n\n");
				$method_ctx->print(tabalign("public void", 32)."set".ucfirst($attr->{name})."(Set<$tied_class->{name}> $attr->{name}_)\n{\n\tthis.$attr->{name} = $attr->{name}_;\n}\n\n");
			}
		}
		elsif ($attr->{stype} eq "assoc") {
			# nothing
		}
		elsif ($attr->{stype} eq "compos") {
			# nothing
			if ($is_primary) {
				my $compos = $attr->getAssocTarget();
				my $compos_class = convertToJavaClass($compos->{name});
				$pk_attr_ctx->print("\@Column(name=\"$attr->{name}\")\n");
				$pk_attr_ctx->print(tabalign("public $compos_class.Pk", 32)."$attr->{name}Pk;\n\n");
				$method_ctx->print(tabalign("public void", 32)."set${compos_class}Pk(${compos_class}.Pk $attr->{name}Pk_)\n{\n\tthis.pk.$attr->{name}Pk = $attr->{name}Pk_;\n}\n\n");
				$method_ctx->print(tabalign("public $compos_class.Pk", 32)."get${compos_class}Pk()\n{\n\treturn this.pk.$attr->{name}Pk;\n}\n\n");
			}
		}
		else {
			dr::Util::doDie("unknown attribute stype: $attr->{name} -> $attr->{stype}");
		}
	}
	if (@primary) {
		$sysimport_ctx->printOnce("import javax.persistence.EmbeddedId;\n");
		$sysimport_ctx->printOnce("import javax.persistence.Embeddable;\n");
		$sysimport_ctx->printOnce("import java.io.Serializable;\n");
		$pk_ctx->print("\@Embeddable\npublic static class Pk implements Serializable\n{\n");
		$pk_ctx->print("\t".tabalign("private static final long serialVersionUID", 32)."= 1L;\n\n");
		my $inpk_ctx = $pk_end_ctx->indentContext(1);
		$inpk_ctx->print(tabalign("public", 32)."Pk()\n{\n}\n\n");
		$inpk_ctx->print(tabalign("public", 32)."Pk(".join(", ", map({ $_->{stype} eq "compos" ? (convertToJavaClass($_->getAssocTarget()->{name}).".Pk $_->{name}Pk") : (dr::prog::java::JavaGenerator::mapJavaAttrType($_)." $_->{name}"); } @primary)).")\n");
		$inpk_ctx->print("{\n");
		foreach my $pka (@primary) {
			my $suff = $pka->{stype} eq "compos" ? "Pk" : "";
			$inpk_ctx->print("\t"."this.$pka->{name}$suff = $pka->{name}$suff;\n");
		}
		$inpk_ctx->print("}\n\n");
		my $hash_cont = "0";
		my $equals_cont = "true";
		foreach my $pka (@primary) {
			my $suff = $pka->{stype} eq "compos" ? "Pk" : "";
			$hash_cont = "($hash_cont)*37+($pka->{name}$suff == null ? 0 : $pka->{name}$suff.hashCode())";
			$equals_cont .= " && ($pka->{name}$suff == null ? s.$pka->{name}$suff == null : $pka->{name}$suff.equals(s.$pka->{name}$suff))";
		}
		$inpk_ctx->print("\@Override\n".tabalign("public int", 32)."hashCode()\n{\n");
		$inpk_ctx->print("\treturn $hash_cont;\n");
		$inpk_ctx->print("}\n\n");
		$inpk_ctx->print("\@Override\n".tabalign("public boolean", 32)."equals(Object o)\n{\n");
		$inpk_ctx->print("\tif (!(o instanceof Pk))\n\t\treturn false;\n\tPk s = (Pk)o;\n");
		$inpk_ctx->print("\treturn $equals_cont;\n");
		$inpk_ctx->print("}\n\n");
		$pk_end_ctx->print("};\n");
		$pk_end_ctx->print("\n\@EmbeddedId\n".tabalign("protected Pk", 32)."pk = new Pk();\n\n");
		$method_ctx->print(tabalign("public Pk", 32)."getPk()\n{\treturn pk;\n}\n\n");
		$method_ctx->print(tabalign("public void", 32)."setPk(Pk pk_)\n{\tthis.pk = pk_;\n}\n\n");
	}
	$fdbean->indent(-1);
	$fdbean->print("};\n");

	$context->{file_trans}->closeFile($fdbean);
}

sub generateOperParamList($)
{
	my $oper			= shift;

	return join(", ",
		map({
				my ( $ptype, $ptagger ) = $_->getFinalTypeWithTagger();
				($ptype->{stype} eq "primitive" ? dr::prog::java::JavaGenerator::mapJavaType($ptype) : convertToJavaClass($ptype->{full}))." $_->{name}"
			} @{$oper->{param_list}})
	);
}

sub generateEntityDaoIf($$$$)
{
	my $context			= shift;
	my $location			= shift;
	my $classname			= shift;
	my $more			= shift;

	my $jbaseclassname = $classname; $jbaseclassname =~ s/::/./g;
	my $jclassname = $jbaseclassname."Dao";
	my $filename = $jclassname; $filename =~ s/\./\//g;
	my $pkgname = $jclassname; $pkgname =~ s/\.\w+$//;
	my $classonly = $jclassname; $classonly =~ s/^.*\.//g;
	my $baseclassonly = $jbaseclassname; $baseclassonly =~ s/^.*\.//g;

	return if ($context->{processed}->{$filename});

	my $model = $context->{model_store}->loadModel($location, $classname);
	my $dao = $model->checkSubModel("${classname}::Dao");

	my $fddao = $context->{file_trans}->updateChanged($context->{dst_dir}."/$filename.java");
	$context->{processed}->{$filename} = 1;

	$fddao->print("package $pkgname;\n\n");
	my $sysimport_ctx = $fddao->rememberContext();
	#$fddao->printOnce($sysimport_ctx, "import java.util.Collection;\n");
	my $import_ctx = $fddao->rememberContext();
	$import_ctx->printOnce("import $jbaseclassname;\n");

	$fddao->printIndented("\n\npublic interface $classonly\n{\n");
	$fddao->indent(1);
	my $method_ctx = $fddao->rememberContext();

	$method_ctx->print(tabalign("public void", 32)."save($baseclassonly obj);\n\n");
	$method_ctx->print(tabalign("public void", 32)."remove($baseclassonly obj);\n\n");
	#$method_ctx->print("public Collection<EntityHolder<$baseclassonly>> list();\n\n");
	if ($dao) {
		for my $oper (grep({ $_->{name} =~ /^dr\.(\w+)\./ } @{$dao->{oper_list}})) {
			dr::Util::doDie("wrong name for dao operation: $oper->{name}") unless ($oper->{name} =~ m/^dr\.(\w+)\.(\w+)$/);
			my $optype = $1;
			my $opname = $2;
			if ($optype eq "load") {
				if (0) {
					$sysimport_ctx->printOnce("import dr.core.EntityHolder;\n");
					$method_ctx->print(tabalign("public EntityHolder<$baseclassonly>", 32)."$opname(".generateOperParamList($oper).");\n\n");
				}
				else {
					$method_ctx->print(tabalign("public $baseclassonly", 32)."$opname(".generateOperParamList($oper).");\n\n");
				}
			}
			elsif ($optype eq "query") {
				$method_ctx->print(tabalign("public ".dr::prog::java::JavaGenerator::mapJavaType($oper->getReturnTypeWithTagger()), 32)."$opname(".generateOperParamList($oper).");\n\n");
			}
			elsif ($optype eq "update") {
				my $ret_type = dr::prog::java::JavaGenerator::mapJavaType($oper->getReturnTypeWithTagger());
				$method_ctx->print(tabalign("public $ret_type", 32)."$opname(".generateOperParamList($oper).");\n\n");
			}
			else {
				dr::Util::doDie("unknown dao operation type: $optype");
			}
		}
	}

	$fddao->indent(-1);
	$fddao->print("};\n");

	$context->{file_trans}->closeFile($fddao);
}

sub generateEntityDaoHib($$$$)
{
	my $context			= shift;
	my $location			= shift;
	my $classname			= shift;
	my $more			= shift;

	my $jbaseclassname = $classname; $jbaseclassname =~ s/::/./g;
	my $jclassname = $jbaseclassname."DaoImpl";
	my $filename = $jclassname; $filename =~ s/\./\//g;
	my $pkgname = $jclassname; $pkgname =~ s/\.\w+$//;
	my $classonly = $jclassname; $classonly =~ s/^.*\.//g;
	my $baseclassonly = $jbaseclassname; $baseclassonly =~ s/^.*\.//g;

	return if ($context->{processed}->{$filename});

	my $model = $context->{model_store}->loadModel($location, $classname);
	my $dao = $model->checkSubModel("${classname}::Dao");

	my $fddao = $context->{file_trans}->updateChanged($context->{dst_dir}."/$filename.java");
	$context->{processed}->{$filename} = 1;

	$fddao->print("package $pkgname;\n\n");
	my $sysimport_ctx = $fddao->rememberContext();
	$sysimport_ctx->printOnce("import $jbaseclassname;\n");
	$sysimport_ctx->printOnce("import org.hibernate.SessionFactory;\n");
	$sysimport_ctx->printOnce("//import org.springframework.dao.DataAccessException;\n");
	$sysimport_ctx->printOnce("import org.springframework.orm.hibernate3.HibernateTemplate;\n");
	$sysimport_ctx->printOnce("import org.springframework.stereotype.Repository;\n");
	$sysimport_ctx->printOnce("import org.springframework.transaction.annotation.Propagation;\n");
	$sysimport_ctx->printOnce("import org.springframework.transaction.annotation.Transactional;\n");

	my $import_ctx = $fddao->rememberContext();

	$fddao->printIndented("\n\n\@Repository\n\@Transactional(readOnly = true)\npublic class $classonly extends dr.core.ContextDao implements ${jbaseclassname}Dao\n{\n");
	$fddao->indent(1);
	my $attr_ctx = $fddao->rememberContext();
	$fddao->printIndented("\n");
	my $method_ctx = $fddao->rememberContext();

	$fddao->printAt($attr_ctx, tabalign("protected HibernateTemplate", 32)."template = null;\n\n");

	$fddao->printAt($method_ctx, tabalign("public void", 32)."setSessionFactory(SessionFactory sessionFactory)\n{\ttemplate = new HibernateTemplate(sessionFactory);\n}\n\n");

	$fddao->printAt($method_ctx, "\@Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)\n".tabalign("public void", 32)."save($baseclassonly obj)\n{\n\ttemplate.saveOrUpdate(obj);\n}\n\n");
	$fddao->printAt($method_ctx, "\@Transactional(readOnly = false, propagation = Propagation.REQUIRES_NEW)\n".tabalign("public void", 32)."remove($baseclassonly obj)\n{\n\ttemplate.delete(obj);\n}\n\n");
	#$fddao->printAt($method_ctx, "\@SuppressWarnings(\"unchecked\")\n".tabalign("public Collection<EntityHolder<$baseclassonly>>", 32)."list()\n{\n\tCollection<EntityHolder<$baseclassonly>> result = new LinkedList<EntityHolder<$baseclassonly>>();\n\tfor ($baseclassonly obj: (Collection<$baseclassonly>)template.find(\"from $baseclassonly\")) {\n\t\tresult.add(new EntityHolder<$baseclassonly>(obj, role));\n\t}\n\treturn result;\n}\n\n");
	if ($dao) {
		for my $oper (grep({ $_->{name} =~ /^dr\.(\w+)\./ } @{$dao->{oper_list}})) {
			dr::Util::doDie("wrong name for dao operation: $oper->{name}") unless ($oper->{name} =~ m/^dr\.(\w+)\.(\w+)$/);
			my $optype = $1;
			my $opname = $2;
			if ($optype eq "load") {
				if (0) {
					$sysimport_ctx->printOnce("import dr.core.EntityHolder;\n");
					$sysimport_ctx->printOnce("import java.util.List;\n");
					$method_ctx->print(tabalign("\@SuppressWarnings(\"unchecked\")\npublic EntityHolder<$baseclassonly>", 32)." $opname(".generateOperParamList($oper).")\n{\n");
					my $cont_ctx = $method_ctx->indentContext(1);
					my $sql = "";
					my $cond = "";
					my $list = "";
					if (defined ($sql = $oper->checkDrTagValue("sql"))) {
						while ($sql =~ m/^(.*?):(\w+)(.*?)$/s) {
							$sql = "$1?$3";
							$list .= ", $2";
						}
					}
					else {
						foreach my $param (@{$oper->{param_list}}) {
							$cond .= " AND $param->{name} = ?";
							$list .= ", $param->{name}";
						}
						$cond = substr($cond, 5);
						$sql = "FROM $baseclassonly WHERE $cond";
					}
					$cont_ctx->print("List<$baseclassonly> result = template.find(\"".escapeString($sql)."\"$list);\n");
					$cont_ctx->print("if (result.size() == 0)\n\treturn null;\n");
					$cont_ctx->print("return new EntityHolder<$baseclassonly>(result.get(0), null);\n");
					$method_ctx->print("}\n\n");
				}
				else {
					$sysimport_ctx->printOnce("import java.util.List;\n");
					$method_ctx->print(tabalign("public $baseclassonly", 32)." $opname(".generateOperParamList($oper).")\n{\n");
					my $cont_ctx = $method_ctx->indentContext(1);
					my $sql = "";
					my $cond = "";
					my $list = "";
					if (defined ($sql = $oper->checkDrTagValue("sql"))) {
						while ($sql =~ m/^(.*?):(\w+)(.*?)$/s) {
							$sql = "$1?$3";
							$list .= ", $2";
						}
					}
					else {
						foreach my $param (@{$oper->{param_list}}) {
							$cond .= " AND $param->{name} = ?";
							$list .= ", $param->{name}";
						}
						$cond = substr($cond, 5);
						$sql = "FROM $baseclassonly WHERE $cond";
					}
					$cont_ctx->print("\@SuppressWarnings(\"unchecked\")\nList<$baseclassonly> result = template.find(\"".escapeString($sql)."\"$list);\n");
					$cont_ctx->print("if (result.size() == 0)\n\treturn null;\n");
					$cont_ctx->print("return result.get(0);\n");
					$method_ctx->print("}\n\n");
				}
			}
			elsif ($optype eq "query") {
				my $ret_type = dr::prog::java::JavaGenerator::mapJavaType($oper->getReturnTypeWithTagger());
				$method_ctx->print(tabalign("public $ret_type", 32)."$opname(".generateOperParamList($oper).")\n{\n");
				my $sql = $oper->getDrTagValue("sql");
				my $cond = "";
				my $list = "";
				while ($sql =~ m/^(.*?):(\w+)(.*?)$/s) {
					$sql = "$1?$3";
					$list .= ", $2";
				}
				$sysimport_ctx->printOnce("import java.util.List;\n");
				$method_ctx->print("\t\@SuppressWarnings(\"rawtypes\")\n\tList result = template.find(\"".escapeString($sql)."\"$list);\n");
				$method_ctx->print("\treturn result.size() == 0 ? null : ($ret_type)result.get(0);\n");
				$method_ctx->print("}\n\n");
			}
			elsif ($optype eq "update") {
				my $ret_type = dr::prog::java::JavaGenerator::mapJavaType($oper->getReturnTypeWithTagger());
				$method_ctx->print(tabalign("public $ret_type", 32)."$opname(".generateOperParamList($oper).")\n{\n");
				my $sql = $oper->getDrTagValue("sql");
				my $cond = "";
				my $list = "";
				while ($sql =~ m/^(.*?):((\w+\.)*\w+)(.*?)$/s) {
					$sql = "$1?$4";
					$list .= ", $2";
				}
				$method_ctx->print("\ttemplate.bulkUpdate(\"".escapeString($sql)."\"$list);\n");
				$method_ctx->print("}\n\n");
			}
			else {
				dr::Util::doDie("unknown dao operation type: $optype");
			}
		}
	}

	$fddao->indent(-1);
	$fddao->print("};\n");

	$context->{file_trans}->closeFile($fddao);
}

sub generateFile($$$$)
{
	my $context			= shift;
	my $location			= shift;
	my $classname			= shift;
	my $gens			= shift;

	foreach my $gen (@$gens) {
		$gen =~ m/^(\w+)(:(.*))?$/
			or dr::Util::doDie("failed to match gen element to word(:options)?: $gen");
		$gen = $1; my $more = $2;
		if ($gen eq "entbean") {
			generateEntityBean($context, $location, $classname, $more);
		}
		elsif ($gen eq "daoif") {
			generateEntityDaoIf($context, $location, $classname, $more);
		}
		elsif ($gen eq "daohib") {
			generateEntityDaoHib($context, $location, $classname, $more);
		}
		else {
			dr::Util::doDie("unknown gen identifier '$gen' for $classname");
		}
	}
}

sub runFile($$$$)
{
	my $model_store		= shift;
	my $src_dir		= shift;
	my $dst_dir		= shift;
	my $relname		= shift;

	my $err = eval {
		my $processor;
		if ($relname =~ m/\.java$/) {
			$processor = dr::prog::java::JavaGenerator->new($file_trans, $model_store, $dst_dir, $src_dir, $relname);
		}
		else {
			$processor = dr::prog::gen::CopyGenerator->new($file_trans, $model_store, $dst_dir, $src_dir, $relname);
		}
		$processor->process()
			or $file_trans->flush(), 0;
	};
	unless (defined $err) {
		STDERR->print("$src_dir/$relname:0: fatal error occurred: $@");
		return 1;
	}
	return $err;
}

sub runDirectories($$)
{
	my $src_dir		= shift;
	my $dst_dir		= shift;

	$src_dir .= "/" unless ($src_dir =~ m,/$,);
	$dst_dir .= "/" unless ($dst_dir =~ m,/$,);
	my @files;
	find({
			no_chdir		=> 1,
			wanted			=> sub {
				if (m/^(\.\/)?(.*\/|)(.*)\.(java|xml|sql)$/) {
					push(@files, $_);
				}
			},
			preprocess		=> sub {
				return unless ($File::Find::dir eq $src_dir || $File::Find::dir."/" eq $src_dir || $File::Find::dir =~ m,^(.*/)(\w+)$,);
				return @_;
			},
		}, $src_dir);

	my $model_store = dr::ModelStore->new($opts{m});

	my $context = {
		file_trans		=> $file_trans,
		src_dir			=> $src_dir,
		dst_dir			=> $dst_dir,
		processed		=> {},
		model_store		=> $model_store,
	};

	foreach my $fullname (@files) {
		die "wrong name: $fullname" unless (substr($fullname, 0, length($src_dir)) eq $src_dir);
		my $relname = substr($fullname, length($src_dir));
		my $src_mtime = (stat("$src_dir$relname"))[9];
		my $dst_mtime = (stat("$dst_dir$relname"))[9];
		next if (defined $dst_mtime && $src_mtime <= $dst_mtime);
		$dst_mtime = "-" unless (defined $dst_mtime);
		STDERR->print("generate from $src_dir$relname: $src_mtime $dst_mtime\n");
		if ((my $err = runFile($model_store, $src_dir, $dst_dir, $relname)) != 0) {
			return $err;
		}
	}

	if (defined $opts{l}) {
		my $fdlist = FileHandle->new("$opts{l}", "<")
			or die "failed to open $opts{l}: $!";
		while (<$fdlist>) {
			chomp;
			s/\s*(|#.*)$//;
			next unless (length($_));
			m/^(\w+)\s+(\S+)\s+(.*)$/
				or die "gen line does not match 'location class gens': $_";
			my $location = $1;
			my $classname = $2;
			my @gens = split(/\s+/, $3);
			$classname =~ s/\./::/g;
			generateFile($context, $location, $classname, \@gens);
		}
	}

	return 0;
}


getopts('dm:l:', \%opts)
	or exit(2);

$file_trans = dr::FileTransaction->new();
my $err;

if ($opts{d}) {
	die "Usage (dir): $0 -d src-dir dst-dir" unless (@ARGV == 2);
	$err = runDirectories($ARGV[0], $ARGV[1]);
}
else {
	die "Usage (file): $0 src-dir dst-dir file" unless (@ARGV == 3);
	$err = runFile(dr::ModelStore->new($opts{m}), $ARGV[0], $ARGV[1], $ARGV[2]);
}

if ($err == 0) {
	$file_trans->commit();
}
undef $file_trans;
exit($err);
