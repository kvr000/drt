#!/usr/bin/perl

###
## drt library
##
## drt multiplatform development toolkit
##
## ----------------------------------------------------------------------------------
##
## Copyright (C) 2004-2008 Zbyněk Vyškovský
##
## ----------------------------------------------------------------------------------
##
## LICENSE:
##
## This file is part of drt
##
## drt is free software; you can redistribute it and/or modify it under the
## terms of the GNU Lesser General Public License as published by the Free
## Software Foundation; either version 3 of the License, or (at your option)
## any later version.
##
## drt is distributed in the hope that it will be useful, but WITHOUT ANY
## WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
## FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for
## more details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with drt; if not, write to the Free Software Foundation, Inc., 51
## Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
##
## @copyright	2004-2008 Zbyněk Vyškovský
## @link	mailto:kvr@matfyz.cz
## @link	http://kvr.matfyz.cz/drt/
## @license	http://www.gnu.org/licenses/lgpl.txt GNU Lesser General Public License v3
###

package dr::GenHeader::FileTransaction;

use strict;
use warnings;

sub new
{
	my $class = shift; $class = ref($class) || $class;

	return bless { opers => [] }, $class;
}

sub commit
{
	my $this		= shift;

	foreach my $op (@{$this->{opers}}) {
		if ($op->{fd}) {
			$op->{fd}->flush();
			if ($op->{fd}->error()) {
				die "failed to write to $op->{fname}: ".$op->{fd}->error();
			}
			close($op->{fd});
			undef $op->{fd};
		}
	}

	$this->{opers} = [];
}

sub createTruncated
{
	my $this		= shift;
	my $fname		= shift;

	my $fd = FileHandle->new($fname, ">")
		or die "failed to open file $fname: $!";
	push(@{$this->{opers}}, { op => "rm", fname => $fname, fd => $fd });
	return $fd;
}

sub DESTROY
{
	my $this		= shift;

	foreach my $op (@{$this->{opers}}) {
		if ($op->{fd}) {
			close($op->{fd});
			undef $op->{fd};
		}
		if ($op->{op} eq "rm") {
			unlink($op->{fname});
		}
		else {
			die "unsupported operation: $op->{op}";
		}
	}
}


package main;

use strict;
use warnings;

use FileHandle;
use Data::Dumper;
use Getopt::Std;

sub fileToName($$)
{
	my $ns			= shift;
	my $file		= shift;

	$file =~ s/.*\///;
	$ns =~ s/::/\//g;
	return "${ns}/${file}";
}

sub fileToHeader($$)
{
	my $ns			= shift;
	my $file		= shift;

	$file =~ s/.*\///;
	$file =~ s/\./__/g;
	$ns =~ s/::/__/g;
	return "${ns}__${file}__";
}

sub nsToMacro($)
{
	my $ns			= shift;
	$ns =~ s/::/_/g;
	$ns = uc($ns);
	return "${ns}_NS";
}

sub nsToMacroBegin($)
{
	return nsToMacro(shift)."_BEGIN";
}

sub nsToMacroEnd($)
{
	return nsToMacro(shift)."_END";
}

sub formatMethodDecl($$)
{
	my $ret			= shift;
	my $decl		= shift;

	my $full = $ret;
	if (length($ret) < 32) {
		$full .= "\t"x((39-length($ret))/8);
	}
	else {
		$full .= " ";
	}
	$full .= $decl;
	return $full;
}

sub readContent($$$)
{
	my $fd			= shift;
	my $lineno		= shift;
	my $fin			= shift;

	my $cont = "";

	while (<$fd>) {
		$$lineno++;
		if (m/^\s*\*\*\//s) {
			die "didn't find close $fin block";
		}
		elsif (m/^\s*\*\s?$fin\s*$/s) {
			return $cont;
		}
		elsif (m/^\s*\* ?(.*)$/s) {
			$cont .= $1;
		}
		else {
			die "unexpected content";
		}
	}
	die "didn't find close $fin block";
}


our %opts;
getopts('i', \%opts);

die "Usage: $0 [-i] cxx_file gen_file_base" unless (@ARGV == 2);
my $cxxname = shift(@ARGV);
die "passed file does not end with suffix .cxx" unless ($cxxname =~ m/(.*)\.cxx$/);
my $basename = shift(@ARGV);
my $hxxname = "$basename.hxx";
my $defname = "$basename-def.hxx";

our $file_trans = dr::GenHeader::FileTransaction->new();

our $hxx;
our $def;
our $str;
our $all;

our $cxx = FileHandle->new($cxxname, "<")
	or die "failed to open $cxxname: $!";

our @cl_list;

our %gen = ();
our @includes = ();
our $ns;
our @ns_use = ();
our @forwards = ();

sub printDirect($$)
{
	my $fd			= shift;
	my $text		= shift;

	if ($fd) {
		$fd->print($text);
	}
}

sub printIndented($$$)
{
	my $fd			= shift;
	my $level		= shift;
	my $text		= shift;

	if ($fd) {
		if ($level > 0) {
			my $ind = "\t" x $level;
			$text =~ s/^(.)/$ind$1/gm;
		}
		$fd->print($text);
	}
}

sub printClass($$);
sub printClass($$)
{
	my $cld			= shift;
	my $level		= shift;

	my $iname= $cld->{class};
	for (my $i = 0; $i < $level; $i++) {
		$iname =~ s/^\w*:://;
	}

	for (my $i = 0; ; $i++) {
		splice(@cl_list, $i, 1), last if ($cl_list[$i] == $cld);
	}

	die "$cxxname:$cld->{defline}: class $cld->{class} has no ancestor" if ($cld->{type} ne "struct" && !defined $cld->{ancestor});

	if ($cld->{doc}) {
		my $doc = $cld->{doc};
		$doc =~ s/^/ \* /gm;
		$doc = "/**\n$doc */\n";
		printIndented($hxx, $level, $doc);
	}
	if ($cld->{type} eq "object") {
		printIndented($hxx, $level, sprintf("%s %s: public %s%s\n{\n", "class", $iname, $cld->{ancestor}, join("", map({ ", $_" } @{$cld->{ifaces}}))));
		printIndented($hxx, $level, sprintf("\tDR_OBJECT_DECL_SIMPLE(%s, %s);\n", $iname, $cld->{ancestor}));
		printDirect($def, "\n");
		printDirect($def, sprintf("DR_OBJECT_IMPL_IFACE%d(%s%s);\n", scalar @{$cld->{ifaces}}, $cld->{class}, join("", map({ ", $_" } @{$cld->{ifaces}}))));
		printDirect($def, sprintf("DR_OBJECT_DEF(%s_STR, %s, %s);\n", nsToMacro($ns), $cld->{class}, $cld->{ancestor}));
	}
	elsif ($cld->{type} eq "noinfo") {
		printIndented($hxx, $level, sprintf("%s %s: public %s\n{", "class", $iname, $cld->{ancestor}));
	}
	elsif ($cld->{type} eq "struct") {
		if (defined $cld->{ancestor}) {
			printIndented($hxx, $level, sprintf("%s %s: public %s\n{", "struct", $iname, $cld->{ancestor}));
		}
		else {
			printIndented($hxx, $level, sprintf("%s %s\n{", "struct", $iname));
		}
	}
	else {
		die "$cxxname:$cld->{defline}: invalid implementation type specified for $cld->{class}";
	}

	if ($cld->{cont} ne "") {
		printDirect($hxx, "\n");
		printIndented($hxx, $level, $cld->{cont});
	}

	for (my $found = 1; $found;) {
		$found = 0;
		foreach (@cl_list) {
			if ($_->{class} =~ m/^$cld->{class}::\w+$/) {
				$found = 1;
				printDirect($hxx, "\n");
				printIndented($hxx, $level, "public:\n");
				printClass($_, $level+1);
				last
			}
		}
	}

	if (@{$cld->{methods}}) {
		my $last_allmod = "---";
		foreach my $met (@{$cld->{methods}}) {
			my $access;
			my $mods = "";
			foreach my $spec (@{$met->{specs}}) {
				$access = $spec, next if ($spec eq "public" || $spec eq "protected" || $spec eq "private");
				$mods .= "$spec ", next if ($spec eq "virtual" || $spec eq "static");
			}
			$access = 'public' unless (defined $access);
			while ($mods =~ s/\b(\w+)\b\s(.*\b\1\b)/$2/) {}
			my $allmod = "-$access-$mods-";
			if ($allmod ne $last_allmod) {
				printDirect($hxx, "\n");
				printIndented($hxx, $level, "$access:\n");
				$last_allmod = $allmod;
			}
			elsif (defined $met->{comment}) {
				printDirect($hxx, "\n");
			}
			if (defined $met->{comment}) {
				my $c = $met->{comment};
				if ($c ne "") {
					$c =~ s/^/\t/mg;
					printIndented($hxx, $level, sprintf("%s", $c));
				}
			}
			printIndented($hxx, $level, sprintf("\t%s;\n", formatMethodDecl("$mods$met->{ret}", "$met->{decl}")));
		}
	}

	if (@{$cld->{ats}}) {
		printDirect($hxx, "\n");
		if (0) {
			if ($cld->{type} eq "struct") {
				printIndented($hxx, $level, "public:\n");
			}
			else {
				printIndented($hxx, $level, "protected:\n");
			}
		}
		my $last_access = "";
		foreach my $at (@{$cld->{ats}}) {
			die "internal error: content of $at doesn't start with [ +-]" unless ($at =~ m/^([-+ ])(.*)$/);
			my ($acc, $def) = ($1, $2);
			if ($acc ne $last_access) {
				printIndented($hxx, $level, sprintf("%s:\n", $acc eq "+" ? "public" : $acc eq " " ? "protected" : $acc eq "-" ? "private" : ""));
				$last_access = $acc;
			}
			printIndented($hxx, $level, sprintf("\t%s\n", $def));
		}
	}

	if (@{$cld->{friends}}) {
		printIndented($hxx, $level, "\npublic:\n");
		foreach my $friend (@{$cld->{friends}}) {
			printIndented($hxx, $level, sprintf("\t%s;\n", formatMethodDecl("friend", $friend)));
		}
	}

	printIndented($hxx, $level, sprintf("};\n"));
}

my $lineno = 0;
my $defline;
my $type = "object";
my $class;
my $class_last;
my $ancestor;
my @ifaces;
my $cont = "";
my @methods;
my @ats;
my @friends;
my $doc;
my @strings;
my @wstrings;
my @bstrings;

my $errors = 0;

my @funcspec;
my $func_comment;
my $func_ret;
my $func_decl;

MAIN: while (<$cxx>) {
	$lineno++;

	if (m/DR_STR\(([^)]*)\)/) {
		my $l = $_;
		while ($l =~ m/DR_STR\(([^)]*)\)(.*)$/) {
			push(@strings, $1);
			$l = $2;
		}
	}
	if (m/DR_BSTR\(([^)]*)\)/) {
		my $l = $_;
		while ($l =~ m/DR_BSTR\(([^)]*)\)(.*)$/) {
			push(@bstrings, $1);
			$l = $2;
		}
	}
	if (m/DR_WSTR\(([^)]*)\)/) {
		my $l = $_;
		while ($l =~ m/DR_WSTR\(([^)]*)\)(.*)$/) {
			push(@wstrings, $1);
			$l = $2;
		}
	}
	if (m,^/\*drt\s*$,) {
		if (defined $class) {
			push(@cl_list, {
					type		=> $type,
					defline		=> $defline,
					class		=> $class,
					ancestor	=> $ancestor,
					ifaces		=> [ @ifaces ],
					cont		=> $cont,
					ats		=> [ @ats ],
					methods		=> [ @methods ],
					friends		=> [ @friends ],
					doc		=> $doc,
				});
			$type = "object";
			undef $class;
			undef $ancestor;
			@ifaces = ();
			$cont = "";
			@ats = ();
			@methods = ();
			@friends = ();
			undef $doc;
		}
		else {
			if (defined $ancestor || $cont ne "" || @ifaces || @ats || @methods || @friends || defined $doc) {
				STDERR->print("no class defined while some of the attributes are"), $errors++;
			}
		}
		while (<$cxx>) {
			$lineno++;
			if (m/^\s*\*\s*$/) {
				next;
			}
			elsif (m/^\s*\*\s*(\w+):\s*(.*?)\s*$/) {
				my ($key, $val) = ($1, $2);
				if ($key eq "include") {
					push(@includes, $val);
				}
				elsif ($key eq "ns") {
					STDERR->printf("$cxxname:$lineno: fatal: ns already defined\n"), exit(1) if (defined $ns);
					$ns = $val;
				}
				elsif ($key eq "gen") {
					%gen = map({ ( $_ => 1 ) } split(/\s+/, $val));
				}
				elsif ($key eq "use") {
					push(@ns_use, $val);
				}
				elsif ($key eq "forward") {
					push(@forwards, $val);
				}
				elsif ($key eq "type") {
					$type = $val;
				}
				elsif ($key eq "class") {
					STDERR->printf("$cxxname:$lineno: fatal: ns undefined\n"), exit(1) unless (defined $ns);
					$class = $val;
					($class_last = $class) =~ s/.*:://;
					$defline = $lineno;
				}
				elsif ($key eq "ancestor") {
					$ancestor = $val;
				}
				elsif ($key eq "ifaces") {
					push(@ifaces, split(/s+/, $val));
				}
				elsif ($key eq "at") {
					push(@ats, " $val");
				}
				elsif ($key eq "ap") {
					push(@ats, "+$val");
				}
				elsif ($key eq "am") {
					push(@ats, "-$val");
				}
				elsif ($key eq "friend") {
					push(@friends, $val);
				}
				elsif ($key eq "co") {
					if ($val eq "{") {
						eval { $cont .= readContent($cxx, \$lineno, "}co") };
						die "$cxxname:$lineno: incorrect syntax for co: $@" if ($@);
					}
					else {
						die "$cxxname:$lineno: incorrect syntax for co: need co:{";
					}
				}
				elsif ($key eq "doc") {
					if ($val eq "{") {
						eval { $doc .= readContent($cxx, \$lineno, "}doc") };
						die "$cxxname:$lineno: incorrect syntax for doc: $@" if ($@);
					}
					else {
						die "$cxxname:$lineno: incorrect syntax for doc: need doc:{";
					}
				}
				else {
					STDERR->printf("$cxxname:$lineno: unknown statement\n");
					$errors++;
				}
			}
			elsif (m/^\s*\*\/\s*$/) {
				last;
			}
			else {
				STDERR->printf("$cxxname:$lineno: incorrect syntax\n"), $errors++;
			}
		}
	}
	elsif (m/^\s*$/) {
		@funcspec = ();
	}
	elsif (m/^{\s*$/) {
		if (defined $func_decl) {
			push(@methods, { specs => [ @funcspec ], ret => $func_ret, decl => $func_decl, comment => $func_comment });
			undef $func_decl;
		}
	}
	elsif (m/^\s/) {
		# skip
	}
	elsif (m/^DR_MET\((.*)\)\s*$/) {
		@funcspec = split(/\s+/, $1);
		undef $func_ret;
		undef $func_decl;
		undef $func_comment;
		STDERR->printf("$cxxname:$lineno: fatal: class undefined\n"), exit(1) unless (defined $class);
		FUNC_DECL: while (<$cxx>) {
			$lineno++;
			#STDERR->printf("class=%s\n", $class);
			#STDERR->printf("regex=%s\n", "^(.*)\\s*($class)::(\\w+)(\\(.*\\)):?\\s*\$");
			#STDERR->print("matching $_");
			if (m/^\/\*\*\s+$/) {
				$func_comment = $_;
				while (<$cxx>) {
					$lineno++;
					$func_comment .= $_;
					next FUNC_DECL if (m/^\s*\*\/\s*$/);
				}
				die "unable to find end of comment";
			}
			if (m/^${class}::(${class_last}\(.*\)(\s*const)?)\s*:?\s*$/) {
				$func_ret = "DR_CONSTRUCT";
				$func_decl = $1;
				last;
			}
			elsif (m/^${class}::(~${class_last}\(\))\s*$/) {
				$func_ret = "";
				$func_decl = $1;
				push(@funcspec, "virtual");
				last;
			}
			elsif (m/^(.*?)\s*($class)::(operator[^(]+)(\(.*\)(\s+const)?)\s*$/) {
				$func_ret = $1;
				$func_decl = "$3$4";
				last;
			}
			elsif (m/^(.*?)\s*($class)::(\w+)(\(.*\)(\s+const)?)\s*$/) {
				$func_ret = $1;
				$func_decl = "$3$4";
				last;
			}
			else {
				STDERR->printf("$cxxname:$lineno: expected method declaration\n");
				$errors++;
				next MAIN;
			}
		}
	}
	else {
		# nothing
	}
}

if (defined $class) {
	push(@cl_list, {
			type		=> $type,
			defline		=> $defline,
			class		=> $class,
			ancestor	=> $ancestor,
			ifaces		=> [ @ifaces ],
			cont		=> $cont,
			ats		=> [ @ats ],
			methods		=> [ @methods ],
			friends		=> [ @friends ],
			doc		=> $doc,
		});
}
else {
	if (defined $ancestor || $cont ne "" || @ifaces || @ats || @methods || @friends || defined $doc) {
		STDERR->print("no class defined while some of the attributes are"), $errors++;
	}
}

if (!%gen) {
	%gen = map({ ( $_ => 1 ) } ( "def", "hxx", "all" ));
	$gen{str} = 1 if (@strings);
}

if ($gen{hxx} || $gen{def}) {
	STDERR->printf("$cxxname:$lineno: fatal: namespace undefined\n"), $errors++ unless (defined $ns);
}
exit(1) if ($errors);

if ($gen{hxx} && !$opts{i}) {
	$hxx = $file_trans->createTruncated("$basename.hxx");
}
if ($gen{def}) {
	$def = $file_trans->createTruncated("$basename-def.hxx");
}
if ($gen{str}) {
	$str = $file_trans->createTruncated("$basename-str.hxx");
}
if ($gen{all}) {
	$all = $file_trans->createTruncated("$basename-all.hxx");
}

if ($all) {
	my $name = $basename;
	$name =~ s/.*\///;
	$all->printf("/* The file is generated from %s, do not modify */\n", $cxxname);
	if ($hxx) {
		$all->printf("#include <%s>\n", fileToName($ns, $hxxname));
	}
	foreach (keys %gen) {
		next if ($_ eq "all" || $_ eq "hxx");
		$all->printf("#include \"_gen/%s-%s.hxx\"\n", $name, $_);
	}
}

if ($str) {
	$str->printf("/* The file is generated from %s, do not modify */\n", $cxxname);
	$str->printf("#include <dr/Const.hxx>\n\n");
	my %printed;
	foreach (@strings) {
		next if ($printed{$_});
		$printed{$_} = 1;
		$str->printf("static const dr::String drstr_%s(dr::Const::string(\"%s\"));\n", $_, $_);
	}
	my %bprinted;
	foreach (@bstrings) {
		next if ($bprinted{$_});
		$bprinted{$_} = 1;
		$str->printf("static const dr::BString drbstr_%s(dr::Const::bstring(\"%s\"));\n", $_, $_);
	}
	my %wprinted;
	foreach (@wstrings) {
		next if ($wprinted{$_});
		$wprinted{$_} = 1;
		$str->printf("static const dr::WString drwstr_%s(dr::Const::wstring(\"%s\"));\n", $_, $_);
	}
}

if ($hxx) {
	$hxx->printf("/* The file is generated from %s, do not modify */\n", $cxxname);
	$hxx->printf("/* The same license applies to use of header file */\n\n");
	$hxx->printf("#ifndef %s\n# define %s\n\n", fileToHeader($ns, $hxxname), fileToHeader($ns, $hxxname));
	foreach my $inc (@includes) {
		$hxx->printf("#include <$inc>\n");
	}
	$hxx->printf("\n%s\n", nsToMacroBegin($ns));
	if (@ns_use) {
		$hxx->printf("\n");
		foreach my $use (@ns_use) {
			$hxx->printf("%s_USE;\n", nsToMacro($use));
		}
	}
	$hxx->printf("\n");
	if (@forwards) {
		$hxx->printf("\n");
		foreach my $forward (@forwards) {
			$hxx->printf("%s\n", $forward);
		}
	}
	$hxx->printf("\n");
}

if ($def) {
	$def->printf("#include <dr/Const.hxx>\n\n");
	$def->printf("%s\n\n", nsToMacroBegin($ns));
}

#STDERR->print(Dumper(\@cl_list));
if (@cl_list) {
	die "class list specified but header not open" unless ($gen{hxx});
	while (@cl_list) {
		my $selected;
		foreach (@cl_list) {
			$selected = $_, last if ($_->{class} !~ m/::/);
		}
		die "$cxxname:$lineno: cannot find any base class in the list: ".Dumper(\@cl_list) unless (defined $selected);
		printClass($selected, 0);
	}
}
if ($def) {
	$def->printf("\n\n%s\n", nsToMacroEnd($ns));
}
if ($hxx) {
	$hxx->printf("\n\n%s\n\n#endif\n", nsToMacroEnd($ns));
}

if ($file_trans->commit()) {
	my $dummy = FileHandle->new("$basename.gen", ">");
	$dummy->printf("ok\n");
	if (!$dummy->close()) {
		die "failed to update dummy file $basename.gen: $!";
	}
}
